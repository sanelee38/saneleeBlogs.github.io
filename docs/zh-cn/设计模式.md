# 设计模式

## 设计模式的目的

编写软件的过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序具有更好的

1. 代码重用性
2. 可读性
3. 可扩展性
4. 可靠性
5. 使程序呈现高内聚，低耦合的特性

## 设计模式七大原则

设计模式原则，其实就是程序员在编程时，应当遵守的原则，也就是各种设计模式的基础

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转（倒置）原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特法则
7. 合成复用原则

### 1.单一职责原则

###### 	基本介绍

对类来说的，即一个类应该只负责一项职责，如类A负责两个不同职责：职责1，职责2，当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1, A2

###### 	单一职责原则数一事项和细节

1. 降低类的复杂度，一个类只负责一项职责
2. 提高类的可读性、可维护性
3. 降低变更引起的风险
4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则

```java
 package com.sanelee.principle.singleresponsiblity;

/**
 * Created by sanelee on 2020/6/13
 */
public class SingleResponsibility1 {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.run("摩托车");
        vehicle.run("汽车");
        vehicle.run("飞机");

    }
}

//交通工具类
//方式一：
//1.在方式1的run方法中，违反了单一职责原则
//2.解决的方案非常简单，根据交通工具运行方法不同，分解成不同类即可
class Vehicle {
    public void run(String vehicle) {
        System.out.println(vehicle + "在公路上运行。。。");
    }
}
```

```java
package com.sanelee.principle.singleresponsiblity;

/**
 * Created by sanelee on 2020/6/13
 */
public class SingleResponsibility2 {
    public static void main(String[] args) {
        RoadVehicle roadVehicle = new RoadVehicle();
        roadVehicle.run("摩托车");
        roadVehicle.run("汽车");

        AirVehicle airVehicle = new AirVehicle();
        airVehicle.run("飞机");

    }
}

//方案2的分析
//1.遵守单一职责原则
//2.但是这样做的改动很大，即将类分解，同时修改客户端
//3.改进：直接修改Vechicle类，改动代码会比较少=》方案三


class RoadVehicle{
    public void run(String vechicle){
        System.out.println(vechicle + "公路运行");
    }
}

class AirVehicle{
    public void run(String vechicle){
        System.out.println(vechicle + "天空运行");
    }
}

class WaterVehicle{
    public void run(String vechicle){
        System.out.println(vechicle + "水中运行");
    }
}

```

```java
package com.sanelee.principle.singleresponsiblity;

/**
 * Created by sanelee on 2020/6/13
 */
public class SingleResponsibility3 {
    public static void main(String[] args) {
        Vehicle2 vehicle2 = new Vehicle2();
        vehicle2.run("汽车");
        vehicle2.runWater("轮船");
        vehicle2.runAir("飞机");
    }
}

//这种修改方法没有对原来的类做大的修改，只是增加方法
//这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
class Vehicle2 {
    public void run(String vehicle) {
        System.out.println(vehicle + "在公路上运行。。。");
    }

    public void runAir(String vehicle) {
        System.out.println(vehicle + "在空中上运行。。。");
    }

    public void runWater(String vehicle) {
        System.out.println(vehicle + "在水中上运行。。。");
    }
}


```

### 2.接口隔离原则

###### 基本介绍

客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

###### 接口隔离原则

应用传统方法的问题和使用接口隔离原则改进

1. 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。
2. 将接口Interface1拆分为独立的几个接口，类A和类C分别于他们需要的接口建立依赖关系。也就是采用接口隔离原则
3. 接口Interface1中出现的方法，根据实际情况拆分为三个接口
4. 代码

```java
//没有使用接口隔离原则的代码
package sanelee.DesignPattern.principle.segregation;

/**
 * @author sanelee
 * @date 2020/6/13
 **/
public class Segregation1 {
    public static void main(String[] args) {

    }
}

interface Interface1{
    void operation1();
    void operation2();
    void operation3();
    void operation4();
    void operation5();
}
class B implements Interface1{

    public void operation1() {
        System.out.println("B中实现了operation1");
    }

    public void operation2() {
        System.out.println("B中实现了operation2");
    }

    public void operation3() {
        System.out.println("B中实现了operation3");
    }

    public void operation4() {
        System.out.println("B中实现了operation4");
    }

    public void operation5() {
        System.out.println("B中实现了operation5");
    }
}

class D implements Interface1{
    public void operation1() {
        System.out.println("D中实现了operation1");
    }

    public void operation2() {
        System.out.println("D中实现了operation2");
    }

    public void operation3() {
        System.out.println("D中实现了operation3");
    }

    public void operation4() {
        System.out.println("D中实现了operation4");
    }

    public void operation5() {
        System.out.println("D中实现了operation5");
    }
}

class A{//A类通过接口Interface1依赖B类，但是只会用到1，2，3方法
    public void depend1(Interface1 i){
        i.operation1();
    }
    public void depend2(Interface1 i){
        i.operation2();
    }
    public void depend3(Interface1 i){
        i.operation3();
    }
}

class C{//C类通过接口Interface1依赖D类，但是只会用到1，4，5方法
    public void depend1(Interface1 i){
        i.operation1();
    }
    public void depend2(Interface1 i){
        i.operation4();
    }
    public void depend3(Interface1 i){
        i.operation5();
    }
}

```

```java
//使用接口隔离原则的代码
package sanelee.DesignPattern.principle.segregation.improve;

/**
 * @author sanelee
 * @date 2020/6/13
 **/
public class Segregation1 {
    public static void main(String[] args) {
        A a = new A();
        a.depend1(new B());//A类通过接口去依赖B类
        a.depend2(new B());//A类通过接口去依赖B类
        a.depend3(new B());//A类通过接口去依赖B类

        C c = new C();
        c.depend1(new D());//C类通过接口去依赖D类
        c.depend4(new D());//C类通过接口去依赖D类
        c.depend5(new D());//C类通过接口去依赖D类
    }
}

interface Interface1{
    void operation1();
}
interface Interface2{
    void operation2();
    void operation3();
}
interface Interface3{
    void operation4();
    void operation5();
}

class B implements Interface1,Interface2{

    public void operation1() {
        System.out.println("B中实现了operation1");
    }

    public void operation2() {
        System.out.println("B中实现了operation2");
    }

    public void operation3() {
        System.out.println("B中实现了operation3");
    }

}

class D implements Interface1,Interface3{
    public void operation1() {
        System.out.println("D中实现了operation1");
    }


    public void operation4() {
        System.out.println("D中实现了operation4");
    }

    public void operation5() {
        System.out.println("D中实现了operation5");
    }
}

class A{//A类通过接口Interface1,Interface2依赖B类，但是只会用到1，2，3方法
    public void depend1(Interface1 i){
        i.operation1();
    }
    public void depend2(Interface2 i){
        i.operation2();
    }
    public void depend3(Interface2 i){
        i.operation3();
    }
}

class C{//C类通过接口Interface1依赖D类，但是只会用到1，4，5方法
    public void depend1(Interface1 i){
        i.operation1();
    }
    public void depend4(Interface3 i){
        i.operation4();
    }
    public void depend5(Interface3 i){
        i.operation5();
    }

}

```



### 3.依赖倒转原则

###### 基本介绍

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒转的中心思想是面向接口编程
4. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在Java中，抽象指的是接口或抽象类，细节就是具体的实现类
5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

###### 依赖关系传递的三种方式和应用案例

>1. 接口传递
>2. 构造方法传递
>3. setter方式传递

:computer:示例代码

```java
package com.sanelee.designpattern.principle.inversion.improve;

/**
 * @author sanelee
 * @date 2020/6/14
 **/
public class DependencyPass {
    public static void main(String[] args) {
        ChangHong changHong = new ChangHong();
//        OpenAndClose openAndClose = new OpenAndClose();
//        openAndClose.open(changHong);

        /**通过构造器进行依赖的传递*/
//        OpenAndClose openAndClose = new OpenAndClose(changHong);
//        openAndClose.open();
        /**通过setter方法进行依赖传递*/
        OpenAndClose openAndClose = new OpenAndClose();
        openAndClose.setTv(changHong);
        openAndClose.open();
    }
}

/**方式1：通过接口传递实现依赖*/
//开关的接口
//interface IOpenAndClose{
//    public void open(ITV tv);//抽象方法，接收接口
//}
///**ITV接口*/
//interface ITV{
//    public void play();
//}
//class ChangHong implements ITV{
//
//    @Override
//    public void play() {
//        System.out.println("长虹电视机，打开");
//    }
//}
///**实现接口*/
//class OpenAndClose implements IOpenAndClose{
//    public void open(ITV tv) {
//        tv.play();
//    }
//}

/**
 * 方式2：通过构造方法依赖传递
 */
//interface IOpenAndClose {
//    public void open();//抽象方法
//}

/**
 * ITV接口
 */
//interface ITV {
//    public void play();
//}
//
//class OpenAndClose implements IOpenAndClose {
//    /** 成员*/
//    public ITV tv;
//
//    /**有参构造器*/
//    public OpenAndClose(ITV tv) {
//        this.tv = tv;
//    }
//
//    public void open() {
//        this.tv.play();
//    }
//}
//class ChangHong implements ITV{
//
//    @Override
//    public void play() {
//        System.out.println("长虹电视机，打开");
//    }
//}
/**方式3，通过setter方法传递*/
interface IOpenAndClose{
    /**抽象方法*/
    public void open();
    public void setTv(ITV tv);
}
interface ITV{
    public void play();
}
class OpenAndClose implements IOpenAndClose{
    private ITV tv;
    public void setTv(ITV tv){
        this.tv = tv;
    }
    public void open(){
        this.tv.play();
    }
}
class ChangHong implements ITV{

    @Override
    public void play() {
        System.out.println("长虹电视机，打开");
    }
}
```

###### 依赖倒转原则的注意事项和细节

1. 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好。
2. 变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
3. 继承时遵循里氏替换原则

### 4.里氏替换原则

OO中的继承性的思考和说明

1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然他不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个集成体系造成破坏
2. 继承再给程序设计带来便利的同时，也带来了弊端。比如使用集成会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到的自雷的功能都有可能产生故障
3. 问题提出：在编程中，如何正确的使用继承

###### 基本介绍

1. 如果对每个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能够透明的使用其自类的对象
2. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
3. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题

:computer:示例代码

```java
package com.sanelee.designpattern.principle.liskov.improve;

public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11-3=" + a.func1(11,3));
        System.out.println("1-8"+a.func1(1,8));

        System.out.println("================");

        B b = new B();
        System.out.println("11-3=" +b.func3(11,3));
        System.out.println("1-8"+b.func3(1,8));
        System.out.println("11+3+9=" + b.func2(11,3));
    }
}
/**创建一个更加基础的基类*/
class Base{
    /**把更加基础的方法和成员写到Base类*/
}
/**A类*/
class A extends Base{
    /***/
    public int func1(int num1,int num2){
        return num1-num2;
    }
}
/**B类继承了A*/
/**增加了一个新功能，完成两个数相加，然后和9求和*/
class B extends Base{
    /**如果B需要使用A类的方法，使用组合的关系*/
    private A a = new A();

    public int func1(int a,int b){
        return a+b;
    }
    public int func2(int a,int b){
        return func1(a,b) + 9;
    }

    /**如果想使用A的方法*/
    public int func3(int a,int b){
        return this.a.func1(a,b);
    }
}
```

### 5.开闭原则

###### 	基本介绍

1. 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则
2. 一个软件实体如类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。
3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
4. 变成中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则。
5. 

方式一：

```java
package com.sanelee.designpattern.principle.ocp;

public class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
    }
}

class GraphicEditor{
    public void drawShape(Shape s){
        if (s.m_type == 1)
            drawRectangle(s);
        else if (s.m_type == 2)
            drawCircle(s);
    }

    public void drawRectangle(Shape r){
        System.out.println("绘制矩形");
    }
    public void drawCircle(Shape r){
        System.out.println("绘制圆形");
    }
}
/**shape类 ，基类*/
class Shape{
    int m_type;
}
class Rectangle extends Shape{
    Rectangle(){
        super.m_type = 1;
    }
}
class Circle extends Shape{
    Circle(){
        super.m_type = 2;
    }
}
```

方式一的优缺点

1. 优点是比较好理解，简单易操作
2. 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少的修改代码
3. 比如我们这时要新增加一个图形种类  三角形，我们需要做如下修改，修改的地方较多

```java
package com.sanelee.designpattern.principle.ocp;

public class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
        graphicEditor.drawShape(new Triangle());
    }
}

class GraphicEditor{
    public void drawShape(Shape s){
        if (s.m_type == 1)
            drawRectangle(s);
        else if (s.m_type == 2)
            drawCircle(s);
        /**新增画三角形*/
        else if (s.m_type == 3)
            drawTriangle(s);
    }

    public void drawRectangle(Shape r){
        System.out.println("绘制矩形");
    }
    public void drawCircle(Shape r){
        System.out.println("绘制圆形");
    }
    /**新增画三角形*/
    public void drawTriangle(Shape r){
        System.out.println("绘制三角形");
    }
}
/**shape类 ，基类*/
class Shape{
    int m_type;
}
class Rectangle extends Shape{
    Rectangle(){
        super.m_type = 1;
    }
}
class Circle extends Shape{
    Circle(){
        super.m_type = 2;
    }
}
/**新增画三角形*/
class Triangle extends Shape{
    Triangle(){
        super.m_type=3;
    }
}
```

方式一的改进的思路分析

思路：把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可，使用方的代码就不需要修改=》满足了开闭原则

```java
package com.sanelee.designpattern.principle.ocp.improve;

public class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
        graphicEditor.drawShape(new Triangle());
        graphicEditor.drawShape(new OtherGraph());
    }
}

class GraphicEditor{
    public void drawShape(Shape s){
        s.draw();
    }

}

/**shape类 ，基类*/
abstract class Shape{
    int m_type;
    /**抽象方法*/
    public abstract void draw();
}

class Rectangle extends Shape{
//    Rectangle(){
//        super.m_type = 1;
//    }

    @Override
    public void draw() {
        System.out.println("绘制矩形");
    }
}

class Circle extends Shape{
//    Circle(){
//        super.m_type = 2;
//    }

    @Override
    public void draw() {
        System.out.println("绘制圆形");
    }
}

/**新增画三角形*/
class Triangle extends Shape{
//    Triangle(){
//        super.m_type=3;
//    }

    @Override
    public void draw() {
        System.out.println("绘制三角形");
    }
}
/**新增一个其他图形*/
class OtherGraph extends Shape{

    @Override
    public void draw() {
        System.out.println("绘制其他图形");
    }
}
```

### 6.迪米特法则

###### 基本介绍

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 迪米特法则（Demeter Principle）又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量讲逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息
4. 迪米特法则还有个更简单的定义：只与直接的朋友通信
5. **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

应用案例：

```java
package com.sanelee.designpattern.principle.demeter;

import java.util.ArrayList;
import java.util.List;

public class Demeter1 {
    public static void main(String[] args) {
        SchoolManager schoolManager = new SchoolManager();
        /**输出学院的员工id和学校总部的员工信息*/
        schoolManager.printAllEmployee(new CollegeManager());
    }
}
/**学校总部员工*/
class Employee{
    private String id;

    public void setId(String id){
        this.id = id;
    }

    public String getId(){
        return id;
    }
}
/**学院员工*/
class CollegeEmployee{
    private String id;

    public void setId(String id){
        this.id = id;
    }
    public String getId(){
        return id;
    }
}
/**管理学院员工的管理类*/
class CollegeManager{
    public List<CollegeEmployee> getAllEmployee(){
        List<CollegeEmployee> list = new ArrayList<>();
        /**增加10个员工到list*/
        for (int i = 0;i<10;i++){
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id= " + i);
            list.add(emp);
        }
        return list;
    }
}
/**学校管理类*/
class SchoolManager{
    public List<Employee> getAllEmployee(){
        List<Employee> list = new ArrayList<>();
        for (int i = 0;i<5;i++){
            Employee emp = new Employee();
            emp.setId("学校总部员工id= "+i);
            list.add(emp);
        }
        return list;
    }
    /**该方法完成输出学校总部和学院员工信息*/
    void printAllEmployee(CollegeManager sub){
        /**获取到学院员工*/
        List<CollegeEmployee> list1 = sub.getAllEmployee();
        System.out.println("-------学院的员工-------");
        for (CollegeEmployee e : list1){
            System.out.println(e.getId());
        }
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("--------学校总部员工------------");
        for (Employee e : list2){
            System.out.println(e.getId());
        }
    }
}

```

改进

```java
package com.sanelee.designpattern.principle.demeter.improve;

import java.util.ArrayList;
import java.util.List;

public class Demeter1 {
    public static void main(String[] args) {
        SchoolManager schoolManager = new SchoolManager();
        /**输出学院的员工id和学校总部的员工信息*/
        schoolManager.printAllEmployee(new CollegeManager());
    }
}

/**学校总部员工*/
class Employee{
    private String id;

    public void setId(String id){
        this.id = id;
    }

    public String getId(){
        return id;
    }
}

/**学院员工*/
class CollegeEmployee{
    private String id;

    public void setId(String id){
        this.id = id;
    }
    public String getId(){
        return id;
    }
}

/**管理学院员工的管理类*/
class CollegeManager{
    public List<CollegeEmployee> getAllEmployee(){
        List<CollegeEmployee> list = new ArrayList<>();
        /**增加10个员工到list*/
        for (int i = 0;i<10;i++){
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id= " + i);
            list.add(emp);
        }
        return list;
    }
    /**输出学院员工的信息*/
    public void printEmployee(){
        /**获取到学院员工*/
        List<CollegeEmployee> list1 = getAllEmployee();
        System.out.println("-------学院的员工-------");
        for (CollegeEmployee e : list1){
            System.out.println(e.getId());
        }
    }
}

/**学校管理类*/
class SchoolManager{
    public List<Employee> getAllEmployee(){
        List<Employee> list = new ArrayList<>();
        for (int i = 0;i<5;i++){
            Employee emp = new Employee();
            emp.setId("学校总部员工id= "+i);
            list.add(emp);
        }
        return list;
    }
    /**该方法完成输出学校总部和学院员工信息*/
    void printAllEmployee(CollegeManager sub){
        /**将输出学院的员工的方法，封装到CollegeManager */
        sub.printEmployee();

        List<Employee> list2 = this.getAllEmployee();
        System.out.println("--------学校总部员工------------");
        for (Employee e : list2){
            System.out.println(e.getId());
        }
    }
}

```



###### 迪米特法则注意事项和细节

1. 迪米特法则的核心是降低类之间的耦合
2. 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系。

### 7. 合成复用原则

###### 基本介绍

原则是尽量使用合成/聚合的方式，而不是使用继承

##### 设计原则核心思想

1. 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
2. 针对j接口编程，而不是针对实现编程
3. 为了交互对象之间的松耦合设计而努力

## UML类图

##### 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合

### 1.依赖关系（Dependence）

只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了。

```java
public class PersonServiceBean {
    private PersonDao personDao;
    public void save(Person person){}
    public IDCard getIDCard(Integer personid){
        return null;
    }
    public void modify(){
        Department department = new Department();
    }

}
public class PersonDao {
}
public class Person {
}
public class IDCard {
}
public class Department {
}

```

![屏幕快照 2020-06-18 上午10.38.14](/Users/sanelee/Desktop/屏幕快照 2020-06-18 上午10.38.14.png)

### 2. 泛化关系

泛化关系实际上就是继承关系，他是依赖关系的特例

```java
public abstract class DaoSupport {
    public void save(Object entity){
    }
    public void delete(Object id){
    }
}
public class PersonServiceBean extends DaoSupport{
}

```



![image-20200618104447749](/Users/sanelee/Library/Application Support/typora-user-images/image-20200618104447749.png)

### 3. 实现关系（Implementation）

实现关系实际上就是A类实现B接口，他是依赖关系的特例

```java
public interface PersonService {
    public void delete(Integer id);
}

public class PersonServiceBean implements PersonService{
    @Override
    public void delete(Integer id) {
        
    }
}
```

![image-20200618104742104](/Users/sanelee/Library/Application Support/typora-user-images/image-20200618104742104.png)

### 4. 关联关系（Association）

关联关系实际上就是类与类之间的联系，他是依赖关系的特例

关联具有导航型：即双向关系或单向关系

关系具有多重性：如“1”（表示有且仅有一个），“0...”（表示0个或者多个），“0，1”（表示0个或者一个），“n...m”（表示n到m个都可以），“m...*”（表示至少m个）。

单向一对一关系

```java
public class Person{
  private IDCard card;
}
public class IDCard{}
```

双向一对一关系

```java
public class Person{
  private IDCard card;
}
public class IDCard{
  private Person person
}
```

### 5. 聚合关系(Aggregation)

聚合关系（Aggregation）表示的是整体和部分的关系，整体和部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航型与多重性。

```java
public class Computer {
    private Mouse mouse;
    private Monitor monitor;

    public void setMouse(Mouse mouse){
        this.mouse = mouse;
    }
    public void setMonitor(Monitor monitor){
        this.monitor = monitor;
    }
}
public class Monitor {
}
public class Mouse {
}
```

![image-20200618110407207](/Volumes/WinToMac/image-20200618110407207.png)

如果我们让Mouse，Monitor和Computer是不可分离的，则升级为组合关系

```java
public class Computer {
    private Mouse mouse = new Mouse();
    private Monitor monitor = new Monitor();
}
public class Client{
  public static void main(String[] args){
    Computer computer = new Computer();
  }
}
```

![image-20200618111029705](/Volumes/WinToMac/image-20200618111029705.png)

### 6. 组合关系（Composition）

组合关系：也是整体与部分的关系，但是整体与部分不可以分开。

```java
public class Person {
    private IDCard card;//聚合关系
    private Head head = new Head();//组合关系
}
public class IDCard {
}
public class Head {
}

```

![image-20200618111403461](/Volumes/WinToMac/image-20200618111403461.png)

## 设计模式类型

##### 设计模式分为三种类型，共23种

1. 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2. 结构性模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3. 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）。



## 创建型模式

### 单例设计模式

所谓的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

###### 单例设计模式八种方式

单例模式有八种方式：

1. 饿汉式（静态常量）
2. 饿汉式（静态代码块）
3. 懒汉式（线程不安全）
4. 懒汉式（线程安全，同步方法）
5. 懒汉式（线程安全，同步代码块）
6. 双重检查
7. 静态内部类
8. 枚举

###### 饿汉式（静态常量）应用实例

步骤如下：

1. 构造器私有化（防止 new）

2. 类的内部创建对象

3. 向外暴露一个静态的公共方法。 getInstance

4. 代码实现

   ```java
   package com.sanelee.designpattern.singleton;
   
   public class type1 {
       public static void main(String[] args) {
           //测试
           Singleton instance = Singleton.getInstance();
           Singleton instance1 = Singleton.getInstance();
           System.out.println(instance == instance1);
           System.out.println(instance.hashCode());
           System.out.println(instance1.hashCode());//同一个对象实例
       }
   }
   
   //饿汉式（静态变量）
   class Singleton{
       //1.构造器私有化,外部不能new
       private Singleton(){
       }
       //2.本类内部创建对象实例
       private final static Singleton instance = new Singleton();
   
       //3.提供一个公有地静态方法，返回实例对象
       public static Singleton getInstance(){
           return instance;
       }
   }
   
   ```

   ###### 优缺点说明

   1. 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
   2. 缺点：在类装载的时候就完成实例化，没有达到Lazy  Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费
   3. 这种方式给予classloader机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果
   4. 结论：这种单例模式可以使用，但是会造成内存浪费

###### 饿汉式（静态代码块）应用实例

1. ```java
   package com.sanelee.designpattern.singleton.type2;
   
   public class SingletonTest02 {
       public static void main(String[] args) {
           //测试
           Singleton instance = Singleton.getInstance();
           Singleton instance1 = Singleton.getInstance();
           System.out.println(instance == instance1);
           System.out.println(instance.hashCode());
           System.out.println(instance1.hashCode());//同一个对象实例
       }
   }
   
   //饿汉式（静态变量）
   class Singleton{
       //1.构造器私有化,外部不能new
       private Singleton(){
       }
   
       //2.本类内部创建对象实例
       private static Singleton instance;
   
       static {//在静态代码块种创建单例对象
           instance = new Singleton();
       }
   
       //3.提供一个公有地静态方法，返回实例对象
       public static Singleton getInstance(){
           return instance;
       }
   }
   
   ```

   ###### 优缺点说明

1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
2. 结论：这种单例模式可用，但是可能造成内存的浪费 

###### 懒汉式（线程不安全）

1. ```java
   package com.sanelee.designpattern.singleton.type3;
   
   public class SingletonTest03 {
       public static void main(String[] args) {
           //测试
           Singleton instance = Singleton.getInstance();
           Singleton instance1 = Singleton.getInstance();
           System.out.println(instance == instance1);
           System.out.println(instance.hashCode());
           System.out.println(instance1.hashCode());//同一个对象实例
       }
   }
   
   class Singleton{
       private static Singleton instance;
       private Singleton(){}
   
       //提供一个静态的公有方法，当使用到该方法时，才去创建instance
       //即懒汉式
       public static Singleton getInstance(){
           if (instance == null){
               instance = new Singleton();
           }
           return instance;
       }
   }
   
   ```

   ###### 优缺点说明

   1. 起到了Lazy Loading的效果，但是只能在单线程下使用。
   2. 如果在多线程下，一个线程进入了if（singleton == null）判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式
   3. 结论：在实际开发中，不要使用这种方式。

###### 双重检查

1. ```java
   package com.sanelee.designpattern.singleton.type6;
   
   public class SingletonTest06 {
       public static void main(String[] args) {
           //测试
           Singleton instance = Singleton.getInstance();
           Singleton instance1 = Singleton.getInstance();
           System.out.println(instance == instance1);
           System.out.println(instance.hashCode());
           System.out.println(instance1.hashCode());//同一个对象实例
       }
   }
   
   class Singleton{
       private static volatile Singleton instance;
       private Singleton(){}
   
       //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题
       public static Singleton getInstance(){
           if (instance == null){
               synchronized (Singleton.class){
                   if (instance == null) {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

   ###### 优缺点说明

   1. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if(singleton == null)检查，这样就可以保证线程安全了。
   2. 这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton == null),直接return实例化对象，也避免反复进行方法同步。
   3. 线程安全；延迟加载；效率较高
   4. 结论：在实际开发中，推荐使用这种单例设计模式

###### 静态内部类

1. ```java
   public class SingletonTest07 {
       public static void main(String[] args) {
           //测试
           Singleton instance = Singleton.getInstance();
           Singleton instance1 = Singleton.getInstance();
           System.out.println(instance == instance1);
           System.out.println(instance.hashCode());
           System.out.println(instance1.hashCode());//同一个对象实例
       }
   }
   //静态内部类完成
   class Singleton{
       private static volatile Singleton instance;
       //构造器私有化
       private Singleton(){}
   
       //写一个静态内部类，该类中有一个静态的属性 Singleton
       //外部类的装载不会导致静态内部类的装载
       //JVM在装载类的时候是线程安全的
       private static class SingletonInstance{
           private static final Singleton INSTANCE = new Singleton();
       }
   
       //提供一个静态的公有方法,直接返回 SingletonInstance.INSTANCE;
       public static Singleton getInstance(){
           return SingletonInstance.INSTANCE;
       }
   }
   ```

   ###### 优缺点说明

   1. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
   2. 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
   3. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
   4. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
   5. 结论：推荐使用

###### 枚举

1. ```java
   public class SingletonTest08 {
       public static void main(String[] args) {
           Singleton instance = Singleton.INSTANCE;
           Singleton instance2 = Singleton.INSTANCE;
           System.out.println(instance == instance2);
   
           System.out.println(instance.hashCode());
           System.out.println(instance2.hashCode());
   
           instance.sayOK();
       }
   }
   //使用枚举，可以实现单例，推荐使用
   enum Singleton{
       INSTANCE;//属性
       public void sayOK(){
           System.out.println("OK!");
       }
   }
   ```

   ###### 优缺点说明：

   1. 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象
   2. 这种方式是Effective Java作者Josh Bloch提倡的方式
   3. 结论：推荐使用

###### 单例设计模式注意事项和细节说明

1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统的性能
2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
3. 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）

++++

### 工厂模式

###### 简单工厂模式

看一个具体的需求，披萨项目：要便于披萨种类的扩展，要便于维护

1. 披萨的种类很多（比如 GreekPizz、CheesePizz等）
2. 披萨的制作有prepare，bake，cut，box
3. 完成披萨店订购功能。

```java
public class OrderPizza {
    //构造器
    public OrderPizza(){
        Pizza pizza = null;
        String orderType;//订购披萨的类型
        do{
            orderType = getType();
            if (orderType.equals("greek")){
                pizza = new GreekPizza();
                pizza.setName("希腊披萨");
            }else if (orderType.equals("cheese")){
                pizza = new CheesePizza();
                pizza.setName("奶酪披萨");
            }else {
                break;
            }
            //输出
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while (true);
    }
    //写一个方法，可以获取客户希望订购的披萨种类
    private String getType(){
        try{
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input pizza type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}
```

```java
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza();
    }
}
```

```java
public class CheesePizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println(" 给制作奶酪披萨 准备原材料");
    }
}
```

```java
public class GreekPizza extends Pizza{
    @Override
    public void prepare() {
        System.out.println(" 给希腊披萨准备原材料 ");
    }
}
```

```java
public abstract class Pizza {
    protected String name;

    public abstract void prepare();

    public void bake(){
        System.out.println(name + " baking;");
    }

    public void cut(){
        System.out.println(name + " cutting,");
    }

    public void box(){
        System.out.println(name + " boxing;");
    }
    public void setName(String name){
        this.name = name;
    }

}

```

1. 传统方式的优缺点
   1. 优点是比较好理解，简单易操作。

   2. 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能时，尽量不修改代码，或者尽可能少修改代码。

   3. 比如我们这时要新增加一个Pizza的种类（Pepper披萨），我们需要新增Pepper类并在OrderPizza中添加ordertype。

   4. 改进的思路分析

      **分析**：修改代码可以接受，但是如果我们在其他的地方也有创建Pizza代码，就意味着也需要修改，而创建Pizza的代码，往往有多处

      **思路**：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该类就可，其他有创建到Pizza对象的代码就不需要修改了 --->简单工厂模式

2. ###### 基本介绍

   1. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
   2. 简单工厂模式：定义了一个创建对象的类，有这个类来封装实例化对象的行为
   3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

```java
public class SimpleFactory {
    /**根据orderType,返回对应的Pizza对象*/
    public Pizza createPizza(String orderType){

        Pizza pizza = null;

        System.out.println("使用简单工厂模式");
        if (orderType.equals("greek")){
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        }else if (orderType.equals("cheese")){
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        }else if (orderType.equals("pepper")){
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        return pizza;
    }
    /**简单工厂模式 也叫静态工厂模式*/
    public static Pizza createPizza2(String orderType){

        Pizza pizza = null;

        System.out.println("使用简单工厂模式2");
        if (orderType.equals("greek")){
            pizza = new GreekPizza();
            pizza.setName("希腊披萨");
        }else if (orderType.equals("cheese")){
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨");
        }else if (orderType.equals("pepper")){
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        return pizza;
    }

}
```

```java
public class OrderPizza {

    /**定义一个简单工厂对象*/
    SimpleFactory simpleFactory;
    Pizza pizza = null;

    //构造器
    public OrderPizza(SimpleFactory simpleFactory){
        setFactory(simpleFactory);
    }
    public void setFactory(SimpleFactory simpleFactory){
        String orderType = "";//用户输入的

        this.simpleFactory = simpleFactory;//设置一个简单工厂对象

        do{
           orderType = getType();
           pizza = this.simpleFactory.createPizza(orderType);
           //输出pizza信息
            if (pizza != null){//订购成功
                pizza.prepare();
                pizza.box();
                pizza.cut();
                pizza.box();
            }else {//订购失败
                System.out.println("订购Pizza失败");
                break;
            }
        }while (true);
    }
    //写一个方法，可以获取客户希望订购的披萨种类
    private String getType(){
        try{
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input pizza type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}
```

```java
public class OrderPizza2 {
    Pizza pizza = null;
    String orderType = "";
    //构造器
    public OrderPizza2(){
        do{
            orderType = getType();
            pizza = SimpleFactory.createPizza2(orderType);
            //输出pizza信息
            if (pizza != null){//订购成功
                pizza.prepare();
                pizza.box();
                pizza.cut();
                pizza.box();
            }else {//订购失败
                System.out.println("订购Pizza失败");
                break;
            }
        }while (true);
    }

    /**写一个方法，可以获取客户端希望订购的披萨种类*/
    private String getType(){
        try{
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input pizza type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}

```

++++++

###### 工厂方法模式

看一个新需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪pizza、北京的胡椒pizza或者是伦敦的奶酪pizza、伦敦的胡椒披萨。

**思路1**：使用简单工厂模式，创建不同的简单工厂类，比如BJPizzaSimpleFactory、LDPizzaSimpleFactory等等。从当前这个案例来说，也是可以的，但是考虑到项目规模，以及软件的可维护性、可扩展性并不是很好

**思路2**：使用工厂方法模式

**工厂方法模式介绍：**
工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。

**工厂方法模式：**定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将**对象的实例化推迟到子类**

```java
public abstract class Pizza {
    protected String name;

    public abstract void prepare();

    public void bake(){
        System.out.println(name + " baking;");
    }

    public void cut(){
        System.out.println(name + " cutting,");
    }

    public void box(){
        System.out.println(name + " boxing;");
    }
    public void setName(String name){
        this.name = name;
    }
}

public class BJCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京的奶酪pizza");
        System.out.println("给北京的奶酪pizza 准备原材料");
    }
}


public class BJPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("北京的胡椒pizza");
        System.out.println("给北京的胡椒pizza 准备原材料");
    }
}

public class LDCheesePizza extends Pizza{
    @Override
    public void prepare() {
        setName("伦敦的奶酪pizza");
        System.out.println("给伦敦的奶酪pizza 准备原材料");
    }
}

public class LDPepperPizza extends Pizza{
    @Override
    public void prepare() {
        setName("伦敦的胡椒pizza");
        System.out.println("给伦敦的胡椒pizza 准备原材料");
    }
}

```

```java
public abstract  class OrderPizza {
    //定义一个抽象方法，createPizza，让各个工厂子类自己实现

    abstract Pizza createPizza(String orderType);

    //构造器
    public OrderPizza(){
        Pizza pizza = null;
        String orderType;//订购披萨的类型
        do{
            orderType = getType();
            pizza = createPizza(orderType); //抽象的方法，由工厂子类完成
            //输出 Pizza制作过程
            pizza.prepare();
            pizza.bake();
            pizza.cut();
            pizza.box();
        }while (true);
    }




    //写一个方法，可以获取客户希望订购的披萨种类
    private String getType(){
        try{
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input pizza type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}

```

```java
public class BJOrderPizza extends OrderPizza {

    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")){
            pizza = new BJCheesePizza();
        } else if (orderType.equals("pepper")){
            pizza = new BJPepperPizza();
        }
        return pizza;

    }
}

public class LDOrderPizza extends OrderPizza {

    @Override
    Pizza createPizza(String orderType) {
        Pizza pizza = null;
        if (orderType.equals("cheese")){
            pizza = new LDCheesePizza();
        } else if (orderType.equals("pepper")){
            pizza = new LDPepperPizza();
        }
        return pizza;

    }
}

```

```java
public class PizzaStory {
    public static void main(String[] args) {
        String loc = "bj";
        if (loc.equals("bj")){
            new BJOrderPizza();
        }else {
            new LDOrderPizza();

        }
    }
}

```

++++

###### 抽象工厂模式

​	基本介绍：

1. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象蔟，而无需指明具体的类
2. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
3. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
4. 将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展

```java
/**抽象工厂模式的抽象层（接口）*/
public interface AbsFactory {
    /**让下面的工厂子类来具体实现*/
    public Pizza createPizza(String orderType);
}
```

```java
public class BJFactory implements AbsFactory {
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println("~使用的是抽象工厂模~`");
        Pizza pizza = null;
        if (orderType.equals("cheese")) {
            pizza = new BJCheesePizza();
        } else if (orderType.equals("pepper")) {
            pizza = new BJPepperPizza();
        }
        return pizza;
    }
}

public class LDFactory implements AbsFactory{
    @Override
    public Pizza createPizza(String orderType) {
        System.out.println("~使用的是抽象工厂模~`");
        Pizza pizza = null;
        if (orderType.equals("cheese")){
            new LDCheesePizza();
        } else if (orderType.equals("pepper")){
            new LDPepperPizza();
        }
        return pizza;
    }
}
```

```java
public class OrderPizza {

    AbsFactory factory;
//构造器
    public OrderPizza(AbsFactory factory){
        setAbsFactory(factory);
    }

    private void setAbsFactory(AbsFactory factory){
        Pizza pizza = null;
        String orderType = "";//用户输入
        this.factory = factory;

        do{
            orderType = getType();
            pizza = factory.createPizza(orderType);
            if (pizza != null){//订购成功
                pizza.prepare();
                pizza.bake();
                pizza.cut();
                pizza.box();
            }else {
                System.out.println("订购失败");
                break;
            }
        }while (true);

    }

    private String getType(){
        try{
            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));
            System.out.println("input pizza type: ");
            String str = strin.readLine();
            return str;
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        }
    }
}

```

```java
public class PizzaStore {
    public static void main(String[] args) {
        new OrderPizza(new BJFactory());
    }
}
```

###### 工厂模式小结

1. 工厂模式的意义

   将实例化对象的代码提取出来，放到一个类中统一管理和维护。达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。

2. 三种工厂模式 （简单工厂模式、工厂方法模式、抽象工厂模式）

3. 设计模式的依赖抽象原则

>- 创建对象实例时，不要直接new类，而是把这个new'类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。
>- 不要让类继承具体类，而是继承抽象类或者是实现interface（接口）
>- 不要覆盖基类中已经实现的方法。

### 原型模式

###### 传统的方式的优缺点

1. 优点是比较好理解，简单易操作。

2. 在创建新的对象时，总是需要重新获取院士对象的属性，如果创建的对象比较复杂时，效率较低。

3. 总是需要重新初始化对象，而不是动态的获得对象运行时的状态，不够灵活

4. 改进的思路分析

   **思路**：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Clonezble，该接口表示该类能够复制且具有复制的能力 ==>原型模式

###### 原型模式基本介绍

1. 原型模式（prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。
3. 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()
4. 形象的理解：孙大圣拔出猴毛，变出其他孙大圣

Prototype：原型类，声明一个克隆自己的借口

ConcretePrototype：具体的原型类，实现一个克隆自己的操作

Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）

>```java
>package com.sanelee.designpattern.prototype.improve;
>
>public class Sheep implements Cloneable{
>    private String name;
>    private int age;
>    private String color;
>    private String address = "蒙古羊";
>    public Sheep friend;//是对象
>
>    public Sheep(String name, int age, String color) {
>        this.name = name;
>        this.age = age;
>        this.color = color;
>    }
>
>    public String getName() {
>        return name;
>    }
>
>    public void setName(String name) {
>        this.name = name;
>    }
>
>    public int getAge() {
>        return age;
>    }
>
>    public void setAge(int age) {
>        this.age = age;
>    }
>
>    public String getColor() {
>        return color;
>    }
>
>    public void setColor(String color) {
>        this.color = color;
>    }
>
>    @Override
>    public String toString() {
>        return "Sheep{" +
>                "name='" + name + '\'' +
>                ", age=" + age +
>                ", color='" + color + '\'' +
>                ", address='" + address + '\'' +
>                '}';
>    }
>
>    /**克隆该实例，使用默认的clone方法来完成*/
>    @Override
>    protected Object clone()  {
>        Sheep sheep = null;
>
>        try {
>            sheep = (Sheep) super.clone();
>        } catch (CloneNotSupportedException e) {
>            System.out.println(e.getMessage());
>        }
>        return sheep;
>    }
>}
>```
>
>```java
>public class Client {
>    public static void main(String[] args) {
>        System.out.println("原型模式完成对象的创建");
>        Sheep sheep = new Sheep("tom", 1, "白色");
>
>        sheep.friend = new Sheep("jack",2,"黑色");
>
>        Object sheep2 = (Sheep) sheep.clone();
>        Object sheep3 = (Sheep) sheep.clone();
>        Object sheep4 = (Sheep) sheep.clone();
>        Object sheep5 = (Sheep) sheep.clone();
>
>        System.out.println("sheep2 = " + sheep2);
>        System.out.println("sheep3 = " + sheep3);
>        System.out.println("sheep4 = " + sheep4);
>        System.out.println("sheep5 = " + sheep5);
>    }
>}
>```

###### 深入讨论-浅拷贝和深拷贝

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
3. 前面的克隆羊就是浅拷贝
4. 浅拷贝是使用默认的clone()方法来实现的  sheep = (Sheep) super.clone();

###### 深拷贝基本介绍

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝
3. 深拷贝实现方式1：重写clone方法来实现深拷贝
4. 深拷贝实现方式2：通过对象序列化实现深拷贝

代码实现:

```java

```

```java
public class DeepProtoType implements Serializable,Cloneable {
    public String name;//String 属性
    public DeepCloneableTarget deepCloneableTarget;//引用类型
    public DeepProtoType(){
        super();
    }

    //深拷贝--方式1 使用clone方法
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object deep = null;
        //这里完成对基本数据类型（属性）的克隆
        deep = super.clone();
        //对引用类型的属性进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType)deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();
        return deepProtoType;
    }

    //深拷贝-- 方式2通过对象的序列化实现（推荐使用）
    public Object deepClone(){

        //创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;

        try {
            //序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);//当前这个对象以对象流的方式输出

            //反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copyObj = (DeepProtoType) ois.readObject();

            return copyObj;

        }catch (Exception e){
            e.printStackTrace();
            return null;
        }finally {
            //关闭流
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public class DeepCloneableTarget implements Cloneable, Serializable {

    private static final long serialVersionUID = 1L;

    private String cloneName;
    private String cloneClass;

    public DeepCloneableTarget(String cloneName, String cloneClass) {
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    }

    @Override
    public String toString() {
        return "DeepCloneableTarget{" +
                "cloneName='" + cloneName + '\'' +
                ", cloneClass='" + cloneClass + '\'' +
                '}';
    }

    //因为该类的属性都是String，因此我们这里使用默认的clone完成即可
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

}

```

```java
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        DeepProtoType p = new DeepProtoType();
        p.name="宋江";
        p.deepCloneableTarget = new DeepCloneableTarget("熊大","熊出没");

        //方式1 完成深拷贝
//        DeepProtoType p2 = (DeepProtoType)p.clone();
//        System.out.println("p.name="+p.name+"p.deepCloneableTarget = "+ p.deepCloneableTarget.hashCode());
//        System.out.println("p2.name="+p2.name+"p2.deepCloneableTarget = "+ p2.deepCloneableTarget.hashCode());


        //方式2 完成深拷贝
        DeepProtoType p2 = (DeepProtoType)p.deepClone();
        System.out.println("p.name="+p.name+"p.deepCloneableTarget = "+ p.deepCloneableTarget.hashCode());
        System.out.println("p2.name="+p2.name+"p2.deepCloneableTarget = "+ p2.deepCloneableTarget.hashCode());
    }
}

```

###### 原型模式的注意事项和细节

1. 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2. 不用重新初始化对象，而是动态的获得对象运行时的状态
3. 如果原始对象发生变化（增加或者减少属性），其他克隆对象也会发生相应的变化，无需修改代码
4. 在实现深克隆的时候可能需要比较复杂的代码
5. **缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。

### 建造者模式

盖房项目需求

1. 需要建房子:这一过程为打桩、砌墙、封顶
2. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的

```java
public abstract class AbstractHouse {
    //打地基
    public abstract void builderBasic();
    //砌墙
    public abstract void builderWalls();
    //封顶
    public abstract void roofed();


    public void build(){
        builderBasic();
        builderWalls();
        roofed();
    }
}


public class CommonHouse extends AbstractHouse{
    @Override
    public void builderBasic() {
        System.out.println("普通房子打地基");
    }

    @Override
    public void builderWalls() {
        System.out.println("普通房子砌墙");
    }

    @Override
    public void roofed() {
        System.out.println("普通房子封顶");
    }
}



public class Client {
    public static void main(String[] args) {
        CommonHouse commonHouse = new CommonHouse();
        commonHouse.build();
    }
}
```

###### 传统方式解决盖房需求问题分析

1. 优点是比较好理解，简单易操作。
2. 设计的程序结构过于简单，没有涉及缓存层对象，程序的扩展和维护不好。也就是说，这种设计方案，把产品和创建产品的过程封装在了一起，耦合性增强了。
3. 解决方案：将产品和产品建造过程解耦===>建造者模式

###### 建造者模式基本介绍

1. 建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构建出不同表现（属性）的对象。
2. 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

###### 建造者模式的四个角色

1. Product（产品角色）：一个具体的产品对象。
2. Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口\抽象类。
3. ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。
4. Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程

```java
package com.sanelee.designpattern.builder.improve;

public class House {
    private String basic;
    private String wall;
    private String roofed;

    public String getBasic() {
        return basic;
    }

    public void setBasic(String basic) {
        this.basic = basic;
    }

    public String getWall() {
        return wall;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }

    public String getRoofed() {
        return roofed;
    }

    public void setRoofed(String roofed) {
        this.roofed = roofed;
    }
}



package com.sanelee.designpattern.builder.improve;

public abstract class HouseBuilder {
    protected House house = new House();

    //将建造的流程写好，抽象的方法
    public abstract void builderBasic();
    public abstract void builderWalls();
    public abstract void roofed();

    //建造好房子，将产品（房子）返回
    public House builderHouse(){
        return house;
    }


}



package com.sanelee.designpattern.builder.improve;

public class HighBuilding extends HouseBuilder{
    @Override
    public void builderBasic() {
        System.out.println("高楼的地基打100米");
    }

    @Override
    public void builderWalls() {
        System.out.println("高楼的砌墙20cm");
    }

    @Override
    public void roofed() {
        System.out.println("高楼的透明屋顶");
    }
}



package com.sanelee.designpattern.builder.improve;

public class CommonHouse extends HouseBuilder{
    @Override
    public void builderBasic() {
        System.out.println("普通房子打地基5米");
    }

    @Override
    public void builderWalls() {
        System.out.println("普通房子砌墙10cm");
    }

    @Override
    public void roofed() {
        System.out.println("普通房子盖屋顶");
    }
}



package com.sanelee.designpattern.builder.improve;

//指挥者，这里去指定制作流程
public class HouseDirector {
    HouseBuilder houseBuilder = null;
    //构造器传入houseBuilder

    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }


    //通过setter 传入houseBuilder

    public void setHouseBuilder(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    //如何处理建造房子的流程，交给指挥者
    public House constructHouse(){
        houseBuilder.builderBasic();
        houseBuilder.builderWalls();
        houseBuilder.roofed();
        return houseBuilder.builderHouse();
    }

}



package com.sanelee.designpattern.builder.improve;

public class Client {
    public static void main(String[] args) {
        //盖普通房
        CommonHouse commonHouse = new CommonHouse();
        //准备创建房子的指挥着
        HouseDirector houseDirector = new HouseDirector(commonHouse);

        //完成盖房，返回产品
        House house = houseDirector.constructHouse();
        System.out.println("==========================");
        //盖高楼
        HighBuilding highBuilding = new HighBuilding();
        //重置建造者
        houseDirector.setHouseBuilder(highBuilding);
        //完成盖房子，返回产品
        houseDirector.constructHouse();
    }
}

```

![../_images/Builder.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg)

###### 建造者模式的注意事项和细节

1. 客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象
3. 可以更加精细的控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便实用程序来控制创建过程
4. 增加新的具体创建者无需修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式
7. 抽象工厂模式**VS**建造者模式：抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品有什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品



## 结构型模式

### 适配器模式

######  基本介绍

1. 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）。
2. 适配器模式属于结构型模式
3. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

###### 适配器模式工作原理

1. 适配器模式：将一个类的接口转换成另一种接口，让原本不兼容的类可以兼容
2. 从用户的角度看不到被适配者，是解耦的
3. 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
4. 用户收到反馈结果，感觉只是和目标接口交互

###### 类适配器模式

**基本介绍**：Adapter类，通过继承src类，实现dst类接口，完成src->dst的适配。

**应用实例**：

1. 以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于src（即被适配者），我们的dst（即目标）是5V直流电

2. 思路图解(类图)

   ![../_images/Adapter_classModel.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg)

3. 代码实现

   ```java
   /**被适配的类*/
   public class Voltage220V {
       public int output220V(){
           int src = 220;
           System.out.println("电压="+src+"伏");
           return src;
       }
   }
   
   /**适配接口*/
   public interface IVoltage5V {
       public int output5V();
   }
   
   public class VoltageAdapter extends Voltage220V implements IVoltage5V{
       @Override
       public int output5V() {
           /**获取到220V电压*/
           int srcV = output220V();
           /**转成5V*/
           int dstV = srcV / 44;
           return dstV;
       }
   }
   
   public class Phone {
       /**充电*/
       public void charging(IVoltage5V iVoltage5V){
           if (iVoltage5V.output5V() == 5){
               System.out.println("电压为5V，可以充电~~~");
           }else if (iVoltage5V.output5V() > 5){
               System.out.println("电压大于5V，不能充电！！！");
           }
       }
   }
   
   
   public class client {
       public static void main(String[] args) {
           System.out.println("===类适配器模式===");
           Phone phone = new Phone();
           phone.charging(new VoltageAdapter());
       }
   }
   
   ```

4. 类适配器模式注意事项和细节

   1. Java是单继承机制，所以类适配器需要继承src类这一点算是个缺点，因为这要求dst必须是接口，有一定局限性；
   2. src类的方法在Adapter中都会暴露出来，也增加了使用的成本
   3. 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了



###### 对象适配器模式

1. 基本思路和类适配器模式相同，只是将Adapter类做修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配
2. 根据“合成复用原则“，在系统中尽量使用关联关系来替代继承关系。
3. 对象适配器模式是适配器模式常用的一种

应用实例

1. 以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于src（即被适配者），我们的dst（即目标）是5V直流电，使用对象适配器模式完成

2. 思路图解

   ![../_images/Adapter.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter.jpg)

   只需修改适配器即可

3. 代码实现

   ```java
   /**被适配的类*/
   public class Voltage220V {
       public int output220V(){
           int src = 220;
           System.out.println("电压="+src+"伏");
           return src;
       }
   }
   
   /**适配接口*/
   public interface IVoltage5V {
       public int output5V();
   }
   
   
   public class VoltageAdapter implements IVoltage5V {
   
       private Voltage220V voltage220V;
   
       /**通过构造器传入实例*/
       public VoltageAdapter(Voltage220V voltage220V) {
           this.voltage220V = voltage220V;
       }
   
       @Override
       public int output5V() {
           int dst = 0;
           if (null != voltage220V){
               int src = voltage220V.output220V();/**获取220V电压*/
               System.out.println("使用对象适配器进行适配~~~");
               dst = src / 44;
               System.out.println("适配完成，输出的电压为="+dst);
           }
           return dst;
       }
   }
   
   public class Phone {
       /**充电*/
       public void charging(IVoltage5V iVoltage5V){
           if (iVoltage5V.output5V() == 5){
               System.out.println("电压为5V，可以充电~~~");
           }else if (iVoltage5V.output5V() > 5){
               System.out.println("电压大于5V，不能充电！！！");
           }
       }
   }
   
   
   public class client {
       public static void main(String[] args) {
           System.out.println("===对象适配器模式===");
           Phone phone = new Phone();
           phone.charging(new VoltageAdapter(new Voltage220V()));
       }
   }
   ```

4. 对象适配器模式注意事项和细节

   1. 对象适配器和类适配器其实算是同一种思想，只不过实现的方式不同。根据合成复用原则，使用聚合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。
   2. 使用成本更低、更灵活

###### 接口适配器模式

1. 一些书籍称为 适配器模式（Default Adapter Pattern）或缺省适配器模式。
2. 当不需要全部实现接口提供的方法时，可以先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆写父类的某些方法来实现需求。
3. 适用于一个接口不想使用其所有的方法的情况。

代码实现

```java
/**接口*/
public interface Interface4 {
    public void m1();
    public void m2();
    public void m3();
    public void m4();
}

/**在ABSAdapter中将interface4的方法进行默认实现*/
public abstract class AbsAdapter implements Interface4{
    public void m1(){}
    public void m2(){}
    public void m3(){}
    public void m4(){}
}


public class Client {
    public static void main(String[] args) {
        AbsAdapter absAdapter = new AbsAdapter() {
            /**只需要去覆盖我们需要使用的接口方法*/
            public void m1() {
                System.out.println("使用了m1的方法");
            }
        };
        absAdapter.m1();
    }
}
```

适配器模式在SpringMVC框架应用的源码剖析

SpringMVC中的HandlerAdapter就使用了适配器模式

### 桥接模式

###### 基本介绍

1. 桥接模式（Bridge模式）是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
2. 是一种结构型设计模式
3. Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Asctraction）与行为实现（Implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

###### 



























