

#### JVM 并发安全如何保证



#### 怎么保证数据库一致性

#### 创建线程的四种方式

> 1.继承Thread类，重写run方法
> 2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target
> 3.通过Callable和FutureTask创建线程
> 4.通过线程池创建线程  （上一篇已经讲过了）
>
> 前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果 
> 后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中



#### 继承Thread类和实现Runnable接口的区别

> 第一种方式：继承Thread类
>
> 步骤：1、定义类继承Thread
>
> ​    2、覆写Threa类的run方法。 自定义代码放在run方法中，让线程运行
>
> ​    3、调用线程的star方法，
>
> 该线程有两个作用：启动线程，调用run方法。
>
> 代码示例：
>
> ```
> 1 class Test extends Thread
> 2 {
> 3     //private String name;
> 4     Test(String name)
> 5     {
> 6         //this.name = name;
> 7         super(name);
> 8     }
> 9     public void run()
> 10     {
> 11         for(int x=0; x<60; x++)
> 12         {
> 13             System.out.println((Thread.currentThread()==this)+"..."+this.getName()+" run..."+x);     //Thread.currentThread():获取当前线程对象
> 14         }
> 15     }
> 16 
> 17 }
> 18 
> 19 
> 20 class ThreadTest 
> 21 {
> 22     public static void main(String[] args) 
> 23     {
> 24         Test t1 = new Test("one---");
> 25         Test t2 = new Test("two+++");
> 26         t1.start();
> 27         t2.start();
> 28 //        t1.run();
> 29 //        t2.run();
> 30 
> 31         for(int x=0; x<60; x++)
> 32         {
> 33             System.out.println("main....."+x);
> 34         }
> 35     }
> 36 }
> ```
>
> 
>
> 
>
> 第二种方式：实现Runnable接口
>
> 
>
> 步骤：1、定义类实现Runnable接口
>
> ​    2、覆盖Runnable接口中的run方法，运行的代码放入run方法中。
>
> ​    3、通过Thread类建立线程对象。
>
> ​    4、将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。
>
> ​       因为，自定义的run方法所属的对象是Runnable接口的子类对象。所以要让线程去指定指定对象的run方法。就必须明确该run方法所属对象
>
> ​    5、调用Thread类的start方法开启线程并调用Runnable接口子类的run方法
>
> 代码示例：卖票程序，多个窗口同时卖票
>
> ```
> 1 class Ticket implements Runnable
> 2 {
> 3     private  int tick = 100;
> 4     public void run()
> 5     {
> 6         while(true)
> 7         {
> 8             if(tick>0)
> 9             {
> 10                 System.out.println(Thread.currentThread().getName()+"....sale : "+ tick--);
> 11             }
> 12         }
> 13     }
> 14 }
> 15 
> 16 
> 17 class  TicketDemo
> 18 {
> 19     public static void main(String[] args) 
> 20     {
> 21 
> 22         Ticket t = new Ticket();
> 23 
> 24         Thread t1 = new Thread(t);//创建了一个线程；
> 25         Thread t2 = new Thread(t);//创建了一个线程；
> 26         Thread t3 = new Thread(t);//创建了一个线程；
> 27         Thread t4 = new Thread(t);//创建了一个线程；
> 28         t1.start();
> 29         t2.start();
> 30         t3.start();
> 31         t4.start();    
> 32     }
> 33 }
> ```
>
> **两种方式的区别：**
>
> **第二种方式好处：避免了单继承的局限性。比如当一个student类继承了person类，再需继承其他的类时就不能了，所以在定义线程时，建议使用第二种方式。**
>
> 
>
> **解决多线程安全性问题：1、同步代码块**
>
> ​                 **2、同步函数：锁为this**
>
> ​                 **3、静态同步函数：  锁为Class对象:类名.class**

#### 线程池

> 线程池五种状态
>
> - Running
>
>   能接受新任务以及处理已添加的任务
>
> - Shutdown
>
>   不接受新任务，可以处理已经添加的任务
>
> - Stop
>
>   不接受新任务，不处理已经添加的任务，并且中断正在处理的任务
>
> - Tidying
>
>   所有的任务已经终止，ctl记录的“任务数量”为0，ctl负责记录线程池的运行状态与活动线程数量
>
> - Terminated
>
>   线程池彻底终止，则线程池转变为terminated状态
>
>   ![线程池状态](E:\面试\线程池状态.PNG)

#### 怎么保证多线程同步

> 1. **同步方法**：即用synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
>
> 2. **同步代码块**：即用synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。
>
> 3. **使用特殊域变量(volatile)实现线程同步**：
>
>    （1）volatile关键字为域变量的访问提供了一种免锁机制；
>
>    （2）使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；
>
>    （3）因此每次使用该域就要重新计算，而不是使用寄存器中的值；
>
>    （4）volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。
>
>    它的原理是每次要线程要访问volatile修饰的变量时都是从内存中读取，而不是从缓存当中读取，因此每个线程访问到的变量值都是一样的。这样就保证了同步。
>
> 4. **使用重入锁实现线程同步**：在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。
>    ReenreantLock类的常用方法有：
>    ReentrantLock() ：创建一个ReentrantLock实例
>    lock() ：获得锁
>    unlock() ：释放锁
>    注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。
>
>    如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 。如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁。
>
> 5. **使用局部变量实现线程同步**：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。
>
>    **ThreadLocal与同步机制**
>
>    a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题；
>
>    b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式。

#### 公平锁/非公平锁

> 公平锁是指多个线程按照申请锁的顺序来获取锁。
> 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
> 对于Java `ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
> 对于`Synchronized`而言，也是一种非公平锁。

#### 可重入锁

> 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。
> 对于Java `ReentrantLock`而言, 他的名字就可以看出是一个可重入锁，其名字是`Re entrant Lock`重新进入锁。
> 对于`Synchronized`而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
>
> ```
> synchronized void setA() throws Exception{
>  Thread.sleep(1000);
>  setB();
> }
> 
> synchronized void setB() throws Exception{
>  Thread.sleep(1000);
> }
> ```
>
> 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。

#### 独享锁/共享锁

> 独享锁是指该锁一次只能被一个线程所持有。
> 共享锁是指该锁可被多个线程所持有。
>
> 对于Java `ReentrantLock`而言，其是独享锁。但是对于Lock的另一个实现类`ReadWriteLock`，其读锁是共享锁，其写锁是独享锁。
> 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
> 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
> 对于`Synchronized`而言，当然是独享锁。

#### 乐观锁/悲观锁

> 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
> 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
> 乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
>
> 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
> 悲观锁在Java中的使用，就是利用各种锁。
> 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

#### 自旋锁

> 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

#### 偏向锁、轻量级锁、重量级锁

> 这三种锁是指锁的状态，并且是针对Synchronized。
>
> - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价
> - 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能
> - 重量级锁是指当锁为轻量级所的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

#### wait、sleep

> - 这两个方法来自不同的类分别是Thread和Object 
> - 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法(锁代码块和方法锁)。
> - wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用(使用范围) 
> - sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 

#### hashmap数据结构



#### hashmap添加数据的过程



#### 数据库保护分为哪几种

> 完整性控制，安全性控制，并发控制，数据恢复

#### MySQL有哪些数据引擎,各自的特点

> **(一)MyISAM**　　它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表
>
> **(二)InnoDB**　　InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。
>
> **(三)MEMORY**　　memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭，表中的数据就会丢失，但表还会继续存在。

#### Java虚拟机的内存结构

1. 程序计数器

   >是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。尤其在多线程的情况下，尤为重要。Java虚拟机的多线程是通过**线程轮流切换并分配处理器执行时间的方式**来实现的，即在任何一个确定时刻，一个处理器只会执行一条线程，当线程切换后就需要恢复到正确位置，因此，程序计数器要实现线程隔离，每个线程都有自己的专属的计数器。值得注意的是：**此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**

2. Java虚拟机栈

   > 此内存区域是Java虚拟机管理的最大一块内存，同时也是**线程共有**的，在**虚拟机启动时创建**。它用来**存储Java中的对象实例**（无论成员变量，局部变量还是类变量，它们指向的对象都存储在堆内存中），几乎所有的对象实例都在这分配内存。同时这里也是GC的主要区域。从内存回收的角度来看，由于收集器基本都采用分代收集法，所以在Java堆中还可以细分为：**新生代**和**老年代**（可以理解为不用代的对象内存位置是不同的）；再细致可分为：Eden空间，From Survivor空间，To Survivor空间（8：1：1）。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。划分的目的是为了更好地**回收内存**或更快的**分配内存**。
   >
   > Java堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可

3. 本地方法栈

   > 它是线程私有的，生命周期与线程相同。三部分组成：**局部变量区**、**操作数栈**、**帧数据区**。
   >
   > 使用其他语言（如C语言）来实现指令集解释器的时候就是使用的本地方法栈

4. Java堆

   > 和虚拟机栈很类似，他们的区别不过是前者为虚拟机执行Native方法服务，后者为虚拟机执行Java方法服务。
   >
   > 供所有类实例和数组对象分配内存的区域

5. 方法区

   > 线程共享的内存区域，作用是**存储Java类的结构信息**。当我们创建对象实例后，对象的类型信息存储在方法区中；实例数据存放在堆中；实例数据指的是Java中创建的各种实例对象以及他们的值，类型信息指的是定义在Java代码中的常量、静态变量以及在类中声明的各种方法、方法字段等；同时可能包括即时编译器编译后产生的代码数据。

   jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作。

   ![img](E:\面试\aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ4OTY2OS8yMDE4MTAvMTQ4OTY2OS0yMDE4MTAwOTE4NTUyNzMxNi0xNzA4NzkwOTc0LnBuZw)

| 名称         | 特征                                                     | 作用                                                         | 配置参数                           | 异常                               |
| ------------ | -------------------------------------------------------- | ------------------------------------------------------------ | ---------------------------------- | ---------------------------------- |
| 程序计数器   | 占用内存小，线程私有，生命周期与线程相同                 | 大致为字节码行号指示器                                       | 无                                 | 无                                 |
| 虚拟机栈     | 线程私有，生命周期与线程相同，使用连续的内存空间         | Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息 | -Xss                               | StackOverflowErrorOutOfMemoryError |
| java堆       | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 保存对象实例，所有对象实例（包括数组）都要在堆上分配         | -Xms-Xsx-Xmn                       | OutOfMemoryError                   |
| 方法区       | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址 | 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 | -XX:PermSize:16M-XX:MaxPermSize64M | OutOfMemoryError                   |
| 运行时常量池 | 方法区的一部分，具有动态性                               | 存放字面量及符号引用                                         |                                    |                                    |

#### Java内存模型

> 虽然java程序所有的运行都是在虚拟机中，涉及到的内存等信息都是虚拟机的一部分，但实际也是物理机的，只不过是虚拟机作为最外层的容器统一做了处理。虚拟机的内存模型，以及多线程的场景下与物理机的情况是很相似的，可以类比参考。
> Java内存模型的主要目标是定义程序中变量的访问规则。即在虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节。需要注意的是这里的变量跟我们写java程序中的变量不是完全等同的。这里的变量是指实例字段，静态字段，构成数组对象的元素，但是不包括局部变量和方法参数(因为这是线程私有的)。这里可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。
> Java内存模型中涉及到的概念有：
>
>  - 主内存：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。
>
> - 工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。线程的工作内存保存了线程需要的变量在主内存中的副本。虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。
>
>   *这里需要说明一下：主内存、工作内存与java内存区域中的java堆、虚拟机栈、方法区并不是一个层次的内存划分。这两者是基本上是没有关系的，上文只是为了便于理解，做的类比*
>
>   ![img](https:////upload-images.jianshu.io/upload_images/4899162-66736384361f6b8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/812/format/webp)

#### jvm类加载过程

> jvm类加载的过程
> java类加载过程：加载-->验证-->准备-->解析-->初始化，之后类就可以被使用了。绝大部分情况下是按这
>
> 样的顺序来完成类的加载全过程的。但是是有例外的地方，解析也是可以在初始化之后进行的，这是为了支持
>
> java的运行时绑定，并且在一个阶段进行过程中也可能会激活后一个阶段，而不是等待一个阶段结束再进行后一个阶段。
>
> 
>
> 1.加载
>
> 加载时jvm做了这三件事：
>
>   1）通过一个类的全限定名来获取该类的二进制字节流
>
>   2）将这个字节流的静态存储结构转化为方法区运行时数据结构
>
>   3）在内存堆中生成一个代表该类的java.lang.Class对象，作为该类数据的访问入口
>
> 2.验证
>
> 验证、准备、解析这三步可以看做是一个连接的过程，将类的字节码连接到JVM的运行状态之中
>
> 验证是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会威胁到jvm的安全
>
> 验证主要包括以下几个方面的验证：
>
> 　　1）文件格式的验证，验证字节流是否符合Class文件的规范，是否能被当前版本的虚拟机处理
>
>   2）元数据验证，对字节码描述的信息进行语义分析，确保符合java语言规范
>
> 　　3）字节码验证 通过数据流和控制流分析，确定语义是合法的，符合逻辑的
>
> 　　4）符号引用验证 这个校验在解析阶段发生
>
> 3.准备  为类的静态变量分配内存，初始化为系统的初始值。对于final static修饰的变量，
>
> 直接赋值为用户的定义值。如下面的例子：这里在准备阶段过后的初始值为0，而不是7
>
> public static int a=7
> 4.解析
>
> 解析是将常量池内的符号引用转为直接引用（如物理内存地址指针）
>
> 5.初始化    
>
> 到了初始化阶段，jvm才真正开始执行类中定义的java代码
>
>    1）初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集
>
>         类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。
>
>    2）当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先触发其父类的初始化。
>
>    3）虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。

#### Springboot怎么通过注解创建对象

`

#### 堆和栈的区别

> ![image-20200909111819868](E:\面试\image-2020090911181981168.png)

#### 编译时注解和运行时注解；性能上有什么差异

1. 编译时注解，注解内容只存在源文件，在编译期间将被丢弃，不能通过JVM获取注解信息；
2. 运行时注解，编译时被存储在.class字节码文件，可以通过JVM运行时获取注解信息(且只限于被RUNTIME注解的注解)。



a）保留阶段不同。运行时注解保留到运行时，可在运行时访问。而编译时注解保留到编译时，运行时无法访问。

b）原理不同。运行时注解是Java反射机制，而编译时注解通过APT、AbstractProcessor。

c）性能不同。运行时注解由于使用Java反射，因此对性能上有影响。编译时注解对性能没影响。这也是为什么ButterKnife从运行时切换到了编译时的原因。

d）产物不同。运行时注解只需自定义注解处理器即可，不会产生其他文件。而编译时注解通常会产生新的Java源文件。



#### java内存回收机制

> 垃圾回收机制是Java语言的一个显著特点，其可以有效的防止内存泄露、保证内存的有效使用，从而使得Java程序在编写程序的死后不需要考虑内存管理的问题。
>
> 程序运行时，内存空间是有限的，那么如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。
>
> 需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。
>
> （1）引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
>
> （2）可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
>
> > 在Java语言中，GC Roots包括：
> >
> > 虚拟机栈中引用的对象。
> >
> > 方法区中类静态属性实体引用的对象。
> >
> > 方法区中常量引用的对象。
> >
> > 本地方法栈中JNI引用的对象。
>
> **静态变量回收**
>
> 一个对象会不会被回收，主要看垃圾回收器引用遍历的时候能不能访问到这个引用，如果访问不到，则将被回收，如果能够访问到，则不能回收。如果一个类的 class文件被装载，那么它的静态成员变量便会被初始化，除非unloader这个类的class对象，他的静态成员变量是不会被gc回收的。

#### GC四大内存回收算法

> **1、标记清除法**
>
> ​	根据被标记的垃圾对象，逐个进行清理。效率高，但是清理回收后，导致内存不连续，形成内存碎片。此时如果有新对象需要消耗更大的内存，虽然总空闲内存足够，由于内存不连续，会导致创建失败。为了解决这个缺陷，故而衍生了下面的复制法。
>
> **2、复制法**
>
> 将可用的内存按容量划分为大小相等的两块（from，to）。每次把没有被标志的，即幸存的对象复制到一边去（to），然后把（from）这块内存格式化的清理。这样子就能保证被清理的内存总是连续可用的。然而，每次只是用其中一块（总有一块是空的【to区域】），造成了内存的使用率折半。
> 针对内存使用率问题底下，复制算法又继续衍生出下面的不均分的三块内存区，其中Eden区占据最大
>
> **3、标记整理法**
>
> ​	把被标记的垃圾对象移动到内存的末端，统一回收。标记整理算法主要是针对Survivor区内存回收的，它的“标记”过程和标记-清除算法一致，只是后面并不是直接对可回收对象进行整理，而是让所有垃圾对象都向末端移动，然后直接清理掉端边界意外的内存。由于标记后继续整理，可以很明显的看出未使用的地址空间都是连续的，不会产生内存碎片。而且不需要复制幸存对象，针对Survivor区，大量对象都是幸存的，可以有效避免重复的复制工作导致性能的浪费。
>
> **4、分代收集法**
>
> ​	根据对象的存活周期的不同而将内存分为几块，分别为新生代、老年代和永久代。
>
> ​    新生代：朝生夕灭的对象（例如：方法的局部变量引用的对象等）。
>
> ​    老年代：存活得比较久，但还是要死的对象（例如：缓存对象、单例对象等）。
>
> ​    永久代：对象生成后几乎不灭的对象（例如：加载过的类信息）。
>
> 新生代：采用复制算法，新生代对象一般存活率较低，因此可以不使用50%的内存作为空闲，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的活动区间与另外80%中存活的对象转移到10%的空闲区间，接下来，将之前90%的内存全部释放，以此类推，
>
> 老年代：老年代中使用“标记-清除”或者“标记-整理”算法进行垃圾回收，回收次数相对较少，每次回收时间比较长。
>
> 永久代指的是虚拟机内存中的方法区，永久代垃圾回收比较少，效率也比较低，但也必须进行垃圾回收，否则永久代内存不够用时仍然会抛出OutOfMemoryError异常。永久代也使用“标记-清除”或者“标记-整理”算法进行垃圾回收
>
> ​	

#### 有序性，原子性，可见性

在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：

**1.原子性**

　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

**2.可见性**

　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

**3.有序性**

　	即程序执行的顺序按照代码的先后顺序执行。

#### tcp和UDP的区别

TCP传输协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议

UDP是Internet协议集支持一个无连接的传输协议，为应用程序提供了一种无需建立连接，就可以发送封装的IP数据包的方法；

TCP面向连接，而UDP是无连接的，也就是说，UDP发送数据前不需要建立连接；

TCP提供的服务更可靠，换句话说，通过TCP连接传输的数据无差错、不丢失、不重复，并且能够按序到达，而UDP不保证可靠交付；

TCP面向字节流，也就是说TCP处理数据时，看成一连串无结构的字节流，而UDP则面向报文的，TCP连接只能是点到点的，但UDP不但支持一对一，还可以一对多、多对一和多对多的交互通信，UDP的首部开销8个字节比TCP的20字节要小。

#### TCP为什么可靠

> **1、序列号与确认号**
>
> 当发送错误的时候，会发生：
>
> **a、超时重传机制**
>
> 发送方发送的报文中含有序列号，每当发送一个报文后，就启动一个计时器（RTO），该计时器的时间一般是有当前网络来决定的，一个RTT指的是当一个报文从发送到接收到对应的ACK标志的时间，RTO的决定一般是发送方尝试发送几个报文，然后取平均RTT时间来决定计时器的值。 当发送一个报文以后，发送方在计时范围以内，如果没有接收到相应的ACK确认报文，那么发送方就会重传该报文。
>
> **b、快速重传机制**
>
> 该机制指的是，发送方一直发送报文，不会每发一次报文就都要等待到这个报文的ACK标志才发送下个报文。 当接收方发送接受的序列号不对的时候，发送连续的3个ACK标志，告诉发送方，这个报文在传输过程中出现了丢包。发送方如果接收到某个相同序列号的三个ACK报文，那么此时立马重发该报文，不用等待计时器的时间结束。
>
> 
>
> **2、流量控制（滑动窗口）**
>
> 发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。此时发送方的报文分为四类， 第一类是已经发送并且得到接收方确认的报文，第二类是已经发送但是没有接收到确认的报文，第三类是发送方还没发送，但是滑动窗口还足够巨大，允许被发送的报文， 第四类是还没发送并且窗口已经被占满，不允许发送的报文。 一般来说，滑动窗口的最左端都是介于第一类跟第二类报文的分界线，最右端是第三类跟第四类报文的分界线。
>
> 滑动窗口的流量控制可以包括那么几个协议：
>
> **a、停等协议。** 滑动窗口的大小为1， 每个发送报文都要等到被确认以后，发送方才继续发送下一个报文。
>
> **b、后退n步协议。** 该协议下，滑动窗口大于1，发送方可以一直发送报文，但是当接收到接收方发送的三个连续的同一序列号的ACK报文时，说明该序列号的报文是已经丢失的，那么此时重发该丢失报文以及该报文以后的报文（包括那些已经发送的）。
>
> **c、选择重传。**在后退n步协议当中，如果某个报文丢失。那么将要重新发送这个丢失报文及以后的所有报文（包括已经发送的），选择重传协议不用做此要求，只要重新发送丢失的报文即可。
>
> .....................（其实还有几种协议，我这里就不继续说了）
>
> **3、拥塞控制**
>
> 首先要明白拥塞控制与流量控制有什么不同，流量控制考虑的是单纯的发送方与接收方，这两个在全部网络过程中的两个端点。而拥塞控制考虑的是整个网络。可以想象一下，在流量控制当中，接收方跟发送方考虑的只是自己的报文有没有发送并且被接收的问题，假设现在网络阻塞，在超时重传机制当中，发送方没有发送后在计时器时间内没有接收到确认报文，就立马重新发送报文，这时候对已经拥塞的网络来说，无异于雪上加霜。同样实在拥塞的网络情况下，考虑下快速重传机制，同样是这个道理。所以，针对以上问题，TCP应该要有一个拥塞控制机制，不然，后果不堪设想。
>
> 在拥塞控制机制当中，发送方会维护一个滑动发送窗口，该窗口与拥塞控制窗口一般是一样大的，除非受到物理限制，假设网络的承载量是无线的，那么拥塞窗口理论上就可以无线增大，但受现在电脑技术限制，我们可能无法将发送窗口与拥塞窗口变得一样大。
>
> 下面说明下几个符号说明：
>
> cwnd：拥塞窗口大小
>
> ssthreshold: 拥塞阈值 （该阈值是对网络状况的一个预估，决定在拥塞窗口多大的时候采取怎样的策略，它的初始化一般是一个估计，一般都会给出）
>
> 
>
> 现在可以看下这个拥塞控制机制包括哪几个策略
>
> **a、慢启动**
>
> 此时一般是（记住是一般情况）cwnd<ssthreshold，此时cwnd呈指数形式增长，1、2、4、8、16、32...这种增长趋势
>
> **b、拥塞避免**
>
> 此时一般cwnd>ssthreshold，此时cwnd呈线性增长，32、33、34、35...这种增长趋势
>
> **c、拥塞解决**
>
> 此时一般是遇到了网络拥塞的状况，解决方法是拥塞阈值乘性减即ssthreshold=cwnd/2，cwnd=1，或者ssthreshold=cwnd/2，cwnd=ssthreshold，这两种情况在后面说明
>
> **d、快速恢复**
>
> 一般是启用拥塞结局策略之后，根据不同的情况，进入慢启动或者拥塞避免阶段。
>
> 
>
> **下面我们模拟一下发送方发送报文**：假设ssthreshold=8
>
> 首先肯定是慢启动阶段，cwnd增长，1、2、4、8，到8的时候，cwnd达到了ssthreshold的值，于是进入拥塞避免阶段，cwnd继续增长8、9、10，假设到10的时候，发生了网络拥塞，这时候拥塞分为两种情况：
>
> 第一种，发送方接收到同一序列号的报文的连续三个ACK确认报文，说明出现了丢包，但是接收到接收方发送的丢包信号，说明网络情况还是相对较好的，于是此时发送方做出反应，将ssthreshold=cwnd/2=5，cwnd=ssthreshold=5，然后进入拥塞避免阶段，cwnd继续以5、6、7....这种情况增长。
>
> 第二种，发送方接收到同一序列号的报文连续两个ACK确认报文，这时候，就说明网络拥塞情况就比较严重了，连接收方发送的丢包信号都不完整了，这个时候得采取更加严厉的措施了，于是ssthreshold=cwnd/2，cwnd=1，然后重新进入慢启动过程。

#### Https的加解密过程

1. 客户端发起HTTPS请求

这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

2. 服务端的配置

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3. 传送证书

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

4. 客户端解析证书

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5. 传送加密信息

这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. 服务段解密信息

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7. 传输加密后的信息

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

8. 客户端解密信息

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

![img](E:\面试\664834-20170920170038103-1215595447.jpg)

#### http协议结构

> 请求报文和响应报文都是由以下4部分组成
>
> 1.请求行
>
> 2.请求头
>
> 3.空行
>
> 4.消息主体
>
> 
>
> 下图为http请求的报文结构
>
> ![img](E:\面试\1090126-20171115074856609-255880765.png)



#### 对称加密和非对称加密

1.对称加密：双方用同一个密码加解密。如des，aes

2.非对称加密：双方各有一对公私密码，公钥公开给别人，别人可以用它来加密；同一对的公钥加密后私钥可解，私钥加密后，公钥可解。如：rsa

**密钥：对称**

又称为共享密钥加密，对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有DES、3DES、AES、RC5、RC6。 

优点是计算速度快；

缺点是密钥需要在通讯的两端共享，也就是不安全啦，因为一个密钥对应两端。

**密钥：非对称** 

又称为公开密钥加密。服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布供任何人使用。 客户端的明文通过公钥加密过的密文需要服务端生成的私钥来解密。

与对称密钥加密相比，非对称加密无需在客户端与服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的。

**密钥：RSA加密简单过程**

- 服务器生成配对的公钥和私钥。
- 私钥保存在服务端，公钥发关给客户端。
- 客户端使用公钥加密明文传输给服务端。
- 服务端使用私钥解密密文得到明文。





给定一棵二叉树，计算该二叉树的最大宽度。二叉树的宽度事指各层宽度的最大值，二叉树每一层的宽度是指最左侧和最右侧的结点之间的距离，而二者之间的null结点也被包含在内。



#### 数组和链表的区别

> **数组**
> 一、数组的特点
> 1.在内存中，数组是一块连续的区域 
> 2.数组需要预留空间
>
> 在使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即数组空间利用率低 
> ps：数组的空间在编译阶段就需要进行确定，所以需要提前给出数组空间的大小（在运行阶段是不允许改变的）
>
> 3.在数组起始位置处，插入数据和删除数据效率低。
>
> 插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移 
> 删除数据时，待删除位置后面的所有元素都需要向前搬移
>
> 4.随机访问效率很高，时间复杂度可以达到O(1)
>
> 因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址处向后偏移就可以访问到了
>
> 5.数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移 
> 6.数组的空间是从栈分配的
>
> 二、数组的优点
> 随机访问性强，查找速度快，时间复杂度为O(1)
>
> 三、数组的缺点
> 1.头插和头删的效率低，时间复杂度为O(N) 
> 2.空间利用率不高 
> 3.内存空间要求高，必须有足够的连续的内存空间 
> 4.数组空间的大小固定，不能动态拓展
>
> **链表**
> 一、链表的特点
> 1.在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续 
> 2.链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址
>
> 每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据
>
> 3.查找数据时效率低,时间复杂度为O(N)
>
> 因为链表的空间是分散的，所以不具有随机访问性，如要需要访问某个位置的数据，需要从第一个数据开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度达到O(N)
>
> 4.空间不需要提前指定大小，是动态申请的，根据需求动态的申请和删除内存空间，扩展方便，故空间的利用率较高 
> 5.任意位置插入元素和删除元素效率较高，时间复杂度为O(1) 
> 6.链表的空间是从堆中分配的
>
> 二、链表的优点
> 1.任意位置插入元素和删除元素的速度快，时间复杂度为O(1) 
> 2.内存利用率高，不会浪费内存 
> 3.链表的空间大小不固定，可以动态拓展
>
> 三、链表的缺点
> 随机访问效率低，时间复杂度为0(N)

#### Java中值类型和引用类型的区别

> 引用类型表示你操作的数据是同一个，也就是说当你传一个参数给另一个方法时，你在另一个方法中改变这个变量的值，那么调用这个方法是传入的变量的值也将改变.
> 		值类型表示复制一个当前变量传给方法，当你在这个方法中改变这个变量的值时，最初生命的变量的值不会变.
>
> **[装箱与拆箱]**
>
> 其实装箱就是值类型到引用类型的转化过程。将一个值类型变量装箱成一个引用类型变量，首先会在托管堆上为新的引用类型变量分配内存空间，然后将值类型变量拷贝到托管堆上新分配的对象内存中，最后返回新分配的对象内存地址。装箱操作是可逆的，所以还有拆箱操作。拆箱操作获取只想对象中包含值类型部分的指针，然后由程序员手动将其对应的值拷贝给值类型变量。



#### hashmap实现



#### 树：红黑树、平衡树、差别



#### osi七层模型

![img](E:\面试\705728-20160424234824085-667046040.png)

 TCP/IP五层协议和OSI的七层协议对应关系如下

![img](E:\面试\705728-20160424234825491-384470376.png)



#### 流量控制+拥塞控制

> **流量控制**：如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。
>
> TCP的流量控制是利用滑动窗口机制实现的，接收方在返回的数据中会包含自己的接收窗口的大小，以控制发送方的数据发送。
>
> **拥塞控制**：拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。
>
> **两者的区别：**流量控制是为了预防拥塞。如：在马路上行车，交警跟红绿灯是流量控制，当发生拥塞时，如何进行疏散，是拥塞控制。流量控制指点对点通信量的控制。而拥塞控制是全局性的，涉及到所有的主机和降低网络性能的因素。
>
> **拥塞解决的两种方法：**
>
> 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
>
> **慢开始+拥塞避免**
>
> 一开始的慢开始算法的指数增长是很恐怖的，所以为了防止拥塞窗口增长过快需要设置一个门限ssthresh
>
> 无论在慢开始阶段还是在拥塞避免阶段，只要发送方没有收到确认，就认为这时候拥塞了。
>
> 1.就要把慢开始门限设置为此时窗口值的一半
>
> 2.然后把拥塞窗口重新设置为1，执行慢开始算法。
>
> **快重传+快恢复**
>
> 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认
>
> 如果没有快速重传和快速恢复，TCP将会使用定时器来要求传输暂停。在暂停这段时间内，没有新的数据包被发送。所以快速重传和快速恢复旨在快速恢复丢失的数据包。
>
> 1.当发送方连续收到三个重复确认时，就把门限减半。
>
> 2.考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将拥塞窗口设置为门限的大小，然后执行拥塞避免算法（加法）。

#### 在浏览器输入一个网址，按回车之后发生了什么

> 1. **浏览器会根据这个URL去查找其对应的IP**
>
>    - 查找浏览器缓存，浏览器会保存之前访问过的一些网站DNS信息。
>    - 如果浏览器缓存没找到对应的ip，浏览器发送一个请求到路由器，然后在路由器缓存上查找记录，路由器一般也才存有DNS信息
>    - 如果还没有，请求将发送到ISP（Internet Service Provider,互联网服务提供商），互联网服务提供商会有相应的DNS服务器，再看IPS的DNS缓存
>    - 解析域名返回ip给浏览器。
>
> 2. **进行TCP链接**
>
>    HTTP包的传输是依靠TCP的传输，建立三次握手，建立TCP链接
>
> 3. **浏览器给这个IP的服务器发生http请求**
>
>    请求包括GET/POST、url、协议、浏览器头、cookies信息等
>
> 4. **服务器收到浏览器请求后，向客户机发送HTTP响应报文**
>
>    包括HTTP版本、事件、cookies等，并查找请求的资源是否存在响应。
>
> 5. **浏览器解析渲染页面**
>
>    当服务器返回响应之后，浏览器读取关于这个相应的说明书（响应头），然后开始解析这个响应并在页面上显示出来。
>
> 6. **关闭TCP链接**
>
>    当数据完成请求到返回的过程之后，根据Connection的Keep-Alive属性可以选择是否断开TCP链接，四次挥手释放

#### http请求头内容

> 请求地址，
>
> 连接类型，
>
> 浏览器信息：浏览器的用户代理信息，浏览器支持的请求类型，。。。。。

#### 三次握手、四次挥手

> **三次握手（three-way handshaking）**
>
> ##### 既要保证数据可靠传输，又要提高传输的效率，而用**三次恰恰可以满足以上两方面的需求！**
>
> 1.背景：TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。
>
> 2.原理：
>
> 1）发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。
>
> 2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。
>
> 3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。
>
> 通俗的说法
>
> 1）Client：嘿，李四，是我，听到了吗？
>
> 2）Server：我听到了，你能听到我的吗?
>
> 3）Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。
>
> **四次挥手（Four-Way-Wavehand）**
>
> **1.意义：**当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
>
> 2.原理：
>
> 1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
>
> 2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
>
> 3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
>
> 4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手
>
> 通俗的说法
>
> 1）Client：我所有东西都说完了
>
> 2）Server：我已经全部听到了，但是等等我，我还没说完
>
> 3）Server：好了，我已经说完了
>
> 4）Client：好的，那我们的通信结束l
>
> **四次挥手为什么时2MSL**
>
> 1、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
>
> 2、他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。
>
> 注意：在服务器发送了FIN-ACK之后，会立即启动超时重传计时器。客户端在发送最后一个ACK之后会立即启动时间等待计时器。



#### B-树 与B+树区别、优点

> ##### 使用B-Tree的好处
>
> B树可以再内部节点存储键值和相关记录数据，因此把频繁访问的数据放在靠近根节点的位置将大大提高热点数据的查询效率。**B树一般在特定数据重复多次查询的场景中更加高效**
>
> ##### 使用B+Tree的好处
>
> B+树内部节点不存储数据，只存储键值，这样，每个节点就能存储更多的键值，一次性也就能将更多的键值读入内存，减少了对磁盘的IO操作次数，且B+树的叶节点有一条链相连，所以对于**区间内查询数据**比较高效
>
> ①B-树的叶子结点不含任何信息，而B+树的叶子结点含信息（关du键字及其记录等）。
> ②B-树上的叶子结点不会指向它的兄弟结点，而B+树上的叶子结点会指向它的兄弟结点。
> 作点解释：这些叶子结点一个指向一个，最终连接成一个链表。
> ③B-树只能进行分区间查找，而B+树上可以有两种查找：顺序查找和分区间查找。
> ④B-树上所有的非叶结点都满足有n个关键字的话有n+1棵子树，而B+树上所有的非叶结点含n个关键字的话只含n棵子树。这个不同引起了如下几点的不同：
>
> （1）B-树的非叶结点有n+1个查找区间，而B+树的却少了一个区间，这个区间恰好是最右边的区间（如果存在，这个区间所指的子树上的所有关键字的值都大于结点的所有关键字的值）。
> （2）在B-树上，除根的非叶结点的子树个数不能少于m/2取上界（这个值用lowbou表示），等价地，关键字的个数不能少于lowbou-1，但在B+树上这个关系发生了变化，除根的其他结点的子树个数同样不能少于lowbou，但关键字的个数却不能少于lowbou，而不是lowbou减一，这个会给B+树的一些算法的具体实现带来不同。
> （3）由于根结点至少需要两棵子树，因而B-树上的根结点的关键字可以只有一个，但是B+树不能，它至少要有两个关键字，这样它才可以有两棵子树（至于为什么根结点都需要两棵子树，是因为它们都是平衡的）。
> ⑤B-树上每一个关键字都配有记录，而在B+树上只有叶子结点上的关键字才配有记录。
> 作点解释：在B+树上，所有关键字的记录（指针）都集中在叶子结点上，其他地方的关键字只是充当索引，并没有与之配有相应的记录的指针。
> ⑥B-树查找可以停在某个非叶结点上，而B+树不能停在非叶结点上，它需要一直查找到叶子结点才能停下，因为B+树的关键字的记录只在叶子结点上。
> 作点补充和解释：在B+树上只要给定的关键字的大小不要比根结点的所有关键字都大（这样就没查找的必要了，因为全树最大的值就在根结点的最右边），那么对于这个关键字的查找，最后一定是停在叶子结点上的，无论它是否存在在B+树上，或者换句话说，无论查找成功与否。
> ⑦B-树上的关键字在全树中出现且仅出现一次，而在B+树上一个关键字可以出现在多个位置，可以有多个，但只有一个位置的关键字配有记录。
> ⑧B+树非叶结点上最右边的关键字表明了它所有子树中关键字的最大值，而B-树没有这规律
> B+树和B-树最大的差别可以说是⑤，甚至这不仅是和B-树的差异，和其他一般的BST树都是这样，B+树上非叶结点上的关键字只是索引，它没有记录，而关键字真正的记录是在叶子结点上。
> 注意：①B-树上非叶结点是全部的内部结点，而B+树上的非叶结点不是全部的内部结点，它除去了最下层的结点。
> ②lowbou是子树下界的意思，或者说最小子树个数。



#### 隔离级别以及问题

> ##### 读未提交（Read uncommitted）
>
> 在这种隔离级别下，所有事务能够读取其他事务未提交的数据。读取其他事务未提交的数据，会造成脏读。因此在该种隔离级别下，不能解决脏读、不可重复读和幻读。
>
> ------
>
> 读未提交可能会产生脏读的现象，那么怎么解决脏读呢？那就是使用读已提交。
>
> ##### **读已提交（Read committed）**
>
> 在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。能够彻底解决脏读的现象。但在这种隔离级别下，会出现一个事务的前后多次的查询中却返回了不同内容的数据的现象，也就是出现了不可重复读。
>
> 注意【1】这是大多数数据库系统默认的隔离级别，例如Oracle和SQL Server，但mysql不是。
>
> ------
>
> 已提交可能会产生不可重复读的现象，我们可以使用可重复读。
>
> ##### 可重复读（Repeatable read）
>
> 在这种隔离级别下，所有事务前后多次的读取到的数据内容是不变的。也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象，从而产生幻读。
>
> 注意【1】这才是mysql的默认事务隔离级别
>
> ------
>
> 可重复读依然会产生幻读的现象，此时我们可以使用串行化来解决。
>
> ##### 可串行化（Serializable）
>
> 在这种隔离级别下，所有的事务顺序执行，所以他们之间不存在冲突，从而能有效地解决脏读、不可重复读和幻读的现象。但是安全和效率不能兼得，这样事务隔离级别，会导致大量的操作超时和锁竞争，从而大大降低数据库的性能，一般不使用这样事务隔离级别。

#### linux查看进程的指令

> 1.查进程
> ps命令查找与进程相关的PID号：
> ps a 显示现行终端机下的所有程序，包括其他用户的程序。
> ps -A 显示所有程序。
> ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。
> ps -e 此参数的效果和指定"A"参数相同。
> ps e 列出程序时，显示每个程序所使用的环境变量。
> ps f 用ASCII字符显示树状结构，表达程序间的相互关系。
> ps -H 显示树状结构，表示程序间的相互关系。
> ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。
> ps s 采用程序信号的格式显示程序状况。
> ps S 列出程序时，包括已中断的子程序资料。
> ps -t<终端机编号> 指定终端机编号，并列出属于该终端机的程序的状况。
> ps u 以用户为主的格式来显示程序状况。
> ps x 显示所有程序，不以终端机来区分。
>
> 最常用的方法是ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。
> ps aux | grep program_filter_word,ps -ef |grep tomcat

#### 进程、线程区别

> 1. 进程是资源分配最小单位，线程是程序执行的最小单位；
> 2. 进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；
> 3. CPU切换一个线程比切换进程花费小；
> 4. 创建一个线程比进程开销小；
> 5. 线程占用的资源要⽐进程少很多。
> 6. 线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）
> 7. 多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；
> 8. 进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；

#### 用户线程（ULT）和内核线程（KLT）

> **用户线程（ULT）**：用户程序实现，不依赖操作系统核心，应用提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括他的所有线程）阻塞。
>
> **内核线程（KLT）**：系统内核管理线程（KLT），内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT要慢，比进程操作快。

#### 进程通信的方式

> 1.管道：速度慢，容量有限，只有父子进程能通讯   
>
> 2.FIFO(命名管道)：任何进程间都能通讯，但速度慢   
>
> 3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   
>
> 4.信号量：不能传递复杂消息，只能用来同步   
>
> 5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

#### 线程间的通信方式

>**1.同步**
>就是通过Synchronized关键字来进行同步访问控制，确保谁拿到了相应的锁才能执行相应的操作
>
>本质上就是共享内存式的通信，这个共享内存在java的内存模型中就是主内存，相当于通过主内存的数据进行线程通信。因Synchronized解锁时会将工作内存中的数据刷新到主内存中，Synchronized加锁时会将工作内存中的值清空从主内存读。多个线程访问同一变量，谁拿到了锁谁就去访问。
>
>**2.while轮询**
>假设我们添加线程向一个List中存入元素（一直存入），判断线程判断如果存入的元素达到了3个，我们就退出存入元素的线程，转而进入另一个等待它存入三个元素的线程。那么这个等待的线程我们使用while轮询list集合中是否达到了三个，如果到了三个我们就进行下一步，没有就一直轮询，
>
>问题：
>
>1.我们发现判断的线程如果没达到它的要求，cpu执行到它时就一直空转，白白浪费
>
>2.这个方法还有一个问题，我们没办法保证可见性，也就是说假设当加入元素的线程到达了3个，但是此时元素数量3只是处于工作内存中，那么在它将工作内存中的3刷新到共享内存中的这段时间中可能又加入了新的元素，加入后等待线程取到值，可是这时候已经大于3了，所以程序会出现问题。
>
>**3.wait/notify机制**
>这是一个Object里的方法，两个方法的作用就是沉睡和唤醒，当我们的等待线程发现没有达到想要的条件我们就沉睡它，此时另一个线程来加入元素，当元素数量达到了3 ，我们可以唤醒等待线程，告诉他你的条件达到了，你继续执行吧
>
>问题：如果说添加元素的线程一下添加了3个，进行了唤醒操作，但是等待线程还没运行到wait，这时产生了次空唤醒。当等待线程执行到wait之后沉睡，因为它要依靠添加元素的线程唤醒，但是添加元素的线程已经进行了唤醒，因此会一直沉睡。
>
>**4.消息管道：**
>就是通过一条管道传输线程之间通信的消息。

#### 虚拟内存、物理内存、共享内存含义

> 虚拟内存是操作系统内核为了对进程地址空间进行管理而精心设计的一个逻辑意义上的内存空间概念。当一个进程启动时，内核会给新的进程建立一个虚拟地址空间。这个虚拟地址空间代表了该进程可能使用到的所有内存
>
> ###### 共享内存
>
> 进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。

#### 死锁产生（衍生到数据库的死锁）

>**由于多个进程竞争共享资源而引起的进程不能向前推进的僵死状态称为死锁。**
>
>1. **死锁产生的原因**
>
> 进程访问资源是通过执行程序实现的，一般来说，进程按照申请资源、访问资源和释放资源的顺序使用资源。**产生死锁的原因为：竞争共享资源并且分配资源的顺序不当。**
>
>2. **产生死锁的必要条件**
>
>   1. **互斥条件**
>
>      指一个进程在访问资源的过程中，其他进程不能访问该资源。如果一个资源正在被访问时，有其他进程也提出对该资源的访问请求，必须把请求该资源的进程阻塞起来，直到资源被进程释放
>
>   2. **请求和保持条件**
>
>      进程已经保持了至少一个资源，又提出了新的资源要求，而新请求的资源已经被其他进程占有，此时进程阻塞，但又对已经获得的资源保持不放，使得其他进程无法使用被保持的资源。
>
>   3. **不剥夺条件**
>
>      进程已经获得的资源不能被剥夺，只能由进程自己释放。
>
>   4. **环路等待条件**
>
>      在发生死锁时，必然存在一个进程申请资源的环行链。即进程集合{p0,p1,p2....,pn}中的p0正在等待一个p1占用的资源；pi正在等待p2占用的资源,...,pn正在等待已经被p0占用的资源
>
>3. **处理死锁的基本方法**
>
> 处理死锁的基本方法有预防死锁、避免死锁、检测并解除死锁和忽略死锁问题（即假定思索不可能在系统内发生而忽略死锁）。
>
> 为确保不发生死锁，操作系统可以采用死锁预防或死锁避免方案。
>
> 1. **死锁的预防**
>
>    死锁预防是根据前面讨论的死锁必要条件，通过保证至少其中一个条件不成立来达到预防发生死锁的目的。
>
>    在操作系统中无法预知进程是否一定不访问临界资源，所以通常不能采用摒弃互斥条件来预防死锁的发生。
>
>    1. 摒弃请求和保持条件
>
>       可以通过摒弃请求和保持条件来预防死锁的发生。摒弃请求和保持条件的一种方法是，系统要求所有进程执行前要一次性地申请在整个运行过程中所需要的全部资源，只要有一个资源申请不成功，其他所有资源也不分配给该进程，并阻塞该进程。
>
>       还有一种方法是对某些进程在申请其他资源前要求该进程必须释放已经分配给它的所有其他资源。
>
>    2. 摒弃不剥夺条件
>
>       摒弃不剥夺条件的方法是一个已经保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放他已经保持的所有资源。这种方法的缺点是实现复杂而且代价高。
>
>    3. 摒弃环路等待条件
>
>       摒弃环路等待的方法是指进程必须按照规定的顺序申请资源。对所有不同类型的资源排序，要求每个进程按规定的顺序申请资源。
>
>       这种方法的缺点如下：
>
>       ​	1） 限制了新设备的增加。
>
>       ​	2） 系统为资源分配的序号与进程实际使用资源的顺序不同，造成资源的浪费。
>
>       ​	3） 给用户编程带来了麻烦
>
> 2. **死锁地避免**
>
>    避免死锁的方法是把系统的资源分配状态分为安全状态和不安全状态，只要资源分配使系统资源分配状态处于安全状态，死锁就不会发生。在避免死锁的方法中，允许进程动态的申请资源。系统在资源分配之前，先计算资源分配的安全性。若本次资源分配不会导致系统进入不安全状态，便将资源分配给进程。否则拒绝进程的资源请求，将进程阻塞起来。
>
>    1. **系统的安全状态**
>
>       当系统能找到一个进程执行序列，使系统只要按此序列为每个进程分配资源，就可以保证进程的资源分配和执行顺利完成，不会发生死锁时，称系统处于安全状态。若系统不存在这样的安全序列，则称系统处于不安全状态。
>
>       不安全状态不一定是死锁状态，但当系统进入不安全状态之后，便可能进入死锁状态。反之，只要系统处于安全状态，系统可避免进入死锁状态。因此避免进程死锁的实质在于使系统处于安全状态。

####  内存溢出和内存泄露

> 内存溢出：（Out Of Memory)
>
> 系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出
>
> 内存泄漏： (Memory Leak)
>
> 强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象

####  Error 和 Exception 区别是什么？

> Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；
>
> Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。

#### 运行时异常和一般异常(受检异常)区别是什么？

> 运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。Java 编译器不会检查运行时异常。
>
> 受检异常是Exception 中除 RuntimeException 及其子类之外的异常。Java 编译器会检查受检异常。
>
> RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。

####  JVM 是如何处理异常的？

> 在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。
>
> JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。

#### throw 和 throws 的区别是什么？

> Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。
>
> throws 关键字和 throw 关键字在使用上的几点区别如下：
>
> - throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。
> - throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。

####  final、finally、finalize 有什么区别？

> - final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
> - finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
> - finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。

#### NoClassDefFoundError 和 ClassNotFoundException 区别？

> NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。
>
> 引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；
>
> ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。

#### try-catch-finally 中哪个部分可以省略？

> catch 可以省略
>
> 原因
>
> 更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。
>
> 理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。
>
> 至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。

#### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

>  答：会执行，在 return 前执行。
>
>  注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。

#### 常见的 RuntimeException 有哪些？

> - ClassCastException(类转换异常)
> - IndexOutOfBoundsException(数组越界)
> - NullPointerException(空指针)
> - ArrayStoreException(数据存储异常，操作数组时类型不一致)
> - 还有IO操作的BufferOverflowException异常

####  Java常见异常有哪些

> - java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。
> - java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.
> - java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。
> - java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。
> - java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。
> - java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。
> - java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。
> - java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。
> - java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。
> - java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。
> - java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。
> - java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。
> - java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。
> - java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。
> - java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。

