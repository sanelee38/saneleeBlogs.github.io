# 数据结构与算法

## 1. 队列介绍

1） 队列是一个有序列表，可以使用数组或是链表来实现。

2）遵循先入先出的原则

## 2. 数组模拟队列的思路

-  队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中 maxSize 是该队列的最大容量。
- 因为队列的输出输入是分别从前后端来处理，因此需要两个变量front 及 rear 分别记录队列前后端的下标， front 会随着数据的输出而改变，而rear则是随着数据的输入而改变。
- 当我们将数据存入队列时称为“addQueue”，addQueue 的处理需要有两个步骤：思路分析
  - 将尾指针往后移：rear+1，当front == rear【空】
  - 若尾指针 rear 小于队列的最大下标 maxSize-1 ，则将数据存入 rear 所指出的数组元素中，否则无法存入数据。rear == maxSize-1【队列满】
- 代码实现

```java
package sanelee.DataStructure;

import java.util.Scanner;

public class ArrayQueueDemo {
    public static void main(String[] args) {
//测试
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key = ' ';//接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //输出一个菜单
        while (loop){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出程序");
            System.out.println("a(add):添加数据到队列");
            System.out.println("g(get):从队列取出数据");
            System.out.println("h(head):查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                   break;
                case 'a':
                    System.out.println("输入一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                   break;
                case 'g'://取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("去除的数据是%d\n",res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h'://查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n",res);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':    //退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }
}
//使用数组模拟队列-变现一个ArrayQueue类
class ArrayQueue{
    private int maxSize;//表示数组的最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//该数据用于存放数据，模拟队列
    //创建队列构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;//指向队列头部，分析出front是指向队列头的前一个位置
        rear = -1;//指向队列尾，指向队列尾的数据（即就是队列最后一个数据）

    }
    //判断队列是否满
    public boolean isFull(){
        return rear == maxSize-1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        //判断队列是否满
        if(isFull()){
            System.out.println("队列满，不能加入数据");
            return;
        }
        rear++;//让rear后移
        arr[rear] = n;
    }
    //获取队列的数据，出队列
    public int getQueue(){
        //判断队列是否空
        if(isEmpty()){
            //通过抛出异常来处理
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;//让front后移
        return arr[front];
    }
    //显示队列的所有数据
    public void showQueue(){
        //遍历
        if (isEmpty()){
            System.out.println("队列为空，没有数据");
            return;
        }
        for (int i = 0;i<arr.length;i++){
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }
    //显示队列的头数据，注意不是取出数据
    public int headQueue(){
        //判断
        if (isEmpty()){
            throw new RuntimeException("队列为空，没有数据");
        }
        return arr[front+1];
    }
}

```

- 问题分析并优化
  - 目前数组使用一次就不能复用，没有达到复用的效果
  - 将这个数组是用的算法，该进程一个环形的队列 取模：%

## 3. 数组模拟环形队列

思路如下：

- front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，front的初始值=0；

- rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear的初始值=0；

- 当队列满时，条件是（rear+1）%maxSize = front [满]

- 队列为空时，rear=front [空]

- 当我们这样分析，队列中有效的数据的个数（rear + maxSize-front）%maxSize

- 我们就可以在原来的队列上修改得到一个环形队列

- 代码实现

  ```java
  package sanelee.DataStructure;
  
  
  import java.util.Scanner;
  
  public class CircleArrayQueue {
      public static void main(String[] args) {
          //测试
          System.out.println("测试数组模拟环形队列的案例-----");
          //创建一个队列
          CircleArray queue = new CircleArray(4);
          char key = ' ';//接收用户输入
          Scanner scanner = new Scanner(System.in);
          boolean loop = true;
          //输出一个菜单
          while (loop) {
              System.out.println("s(show):显示队列");
              System.out.println("e(exit):退出程序");
              System.out.println("a(add):添加数据到队列");
              System.out.println("g(get):从队列取出数据");
              System.out.println("h(head):查看队列头的数据");
              key = scanner.next().charAt(0);//接收一个字符
              switch (key) {
                  case 's':
                      queue.showQueue();
                      break;
                  case 'a':
                      System.out.println("输入一个数");
                      int value = scanner.nextInt();
                      queue.addQueue(value);
                      break;
                  case 'g'://取出数据
                      try {
                          int res = queue.getQueue();
                          System.out.printf("去除的数据是%d\n", res);
                      } catch (Exception e) {
                          System.out.println(e.getMessage());
                      }
                      break;
                  case 'h'://查看队列头的数据
                      try {
                          int res = queue.headQueue();
                          System.out.printf("队列头的数据是%d\n", res);
                      } catch (Exception e) {
                          System.out.println(e.getMessage());
                      }
                      break;
                  case 'e':    //退出
                      scanner.close();
                      loop = false;
                      break;
                  default:
                      break;
              }
          }
          System.out.println("程序退出");
      }
  }
  
  class CircleArray {
      private int maxSize;//表示数组的最大容量
      //front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，
      // front的初始值=0；
      private int front;//队列头
      //rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，
      // rear的初始值=0；
      private int rear;//队列尾
      private int[] arr;//该数据用于存放数据，模拟队列
  
      public CircleArray(int arrMaxSize) {
          maxSize = arrMaxSize;
          arr = new int[maxSize];
      }
  
      //判断是否满
      public boolean isFull() {
          return (rear + 1) % maxSize == front;
      }
  
      //判断队列是否为空
      public boolean isEmpty() {
          return rear == front;
      }
  
      //添加数据到队列
      public void addQueue(int n) {
          //判断队列是否满
          if (isFull()) {
              System.out.println("队列满，不能加入数据");
              return;
          }
          //直接将数据加入
          arr[rear] = n;
          rear = (rear + 1) % maxSize;
      }
  
      //获取队列的数据，出队列
      public int getQueue() {
          //判断队列是否空
          if (isEmpty()) {
              //通过抛出异常来处理
              throw new RuntimeException("队列空，不能取数据");
          }
          //这里需要分析出front是指向队列的第一个元素
          //1.先把front对应的值保留到一个临时变量
          //2.将front后移
          //3.将临时保存的变量返回
          int value = arr[front];
          front = (front + 1) % maxSize;
          return value;
      }
  
      //显示队列的所有数据
      public void showQueue() {
          //遍历
          if (isEmpty()) {
              System.out.println("队列为空，没有数据");
              return;
          }
          //思路：从front开始遍历，遍历多少个元素
          for (int i = front; i < front + size(); i++) {
              System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
          }
      }
  
      //求出当前队列的有效数据的个数
      public int size() {
          return (rear + maxSize - front) % maxSize;
      }
  
      //显示队列的头数据，注意不是取出数据
      public int headQueue() {
          //判断
          if (isEmpty()) {
              throw new RuntimeException("队列为空，没有数据");
          }
          return arr[front];
      }
  }
  
  
  ```


## 4. 链表

### 4.1 链表(Linked List)介绍

(1) 链表是以节点的方式来存储的，是链式存储.

(2) 每个节点包含data 域，next域:指向下一个节点

(3) 链表的各个节点不一定是连续存储的

(4) 链表分为带有头节点的链表和没有头结点的链表，根据实际需求来确定

### 4.2 单链表的应用实例

使用带头结点的单项链表实现  水浒英雄排行榜管理完成对英雄人物的增删改查操作

​		1）第一种方法再添加英雄时，直接添加到链表的尾部

​		2）第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果有这个排名，提示插入失败）

​		3）修改节点的功能

​		4）删除节点的功能

:computer:代码演示

- ```java
  package sanelee.DataStructure;
  
  public class SingleLinkedListDemo {
      public static void main(String[] args) {
          //进行测试
          //先创建节点
          HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
          HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
          HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
          HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
  
          HeroNode heroNode = new HeroNode(2,"小卢","小尾巴");
  
          //创建要加入的链表
          SingleLinkedList singleLinkedList = new SingleLinkedList();
  //        //加入
  //        singleLinkedList.add(hero1);
  //        singleLinkedList.add(hero2);
  //        singleLinkedList.add(hero3);
  //        singleLinkedList.add(hero4);
  
  
          singleLinkedList.addByOrder(hero3);
          singleLinkedList.addByOrder(hero4);
          singleLinkedList.addByOrder(hero1);
          singleLinkedList.addByOrder(hero2);
  
  
          singleLinkedList.list();
          System.out.println("----------");
          //修改节点
  
          singleLinkedList.update(heroNode);
          //显示
          singleLinkedList.list();
          System.out.println("-------");
          //删除一个节点
  
          singleLinkedList.delete(1);
          singleLinkedList.delete(2);
          singleLinkedList.delete(3);
          singleLinkedList.delete(4);
          System.out.println("删除后链表");
          singleLinkedList.list();
      }
  }
  //定义SingleLinkedList 管理英雄
  class SingleLinkedList{
      //先初始化一个头节点，头节点不要动，不存放具体的数据
      private HeroNode head = new HeroNode(0,"","");
  
      //添加节点到单向列表
      //思路，当不考虑编号的顺序时
      //1.找到当前链表的最后节点
      //2.将最后这个节点的next指向新的节点
      public void add(HeroNode heroNode){
          //因为head节点不能动，因此我们需要一个辅助遍历temp
          HeroNode temp = head;
          //遍历链表，找到最后
          while(true){
              //找到链表的最后
              if (temp.next == null){
                  break;
              }
              //如果没有找到随后，将temp后移
              temp = temp.next;
          }
          //当退出while循环时，temp就指向了链表的最后
          //将最后的这个节点的next指向新的节点
          temp.next = heroNode;
      }
      //第二种方式再添加英雄时，根据排名将英雄插入到指定位置中
      //（如果有这个排名，则添加失败，并给出提示）
      public void addByOrder(HeroNode heroNode) {
          //因为head节点不能动，因此我们需要一个辅助变量temp来帮助找到添加的位置
          //因为单链表，所以我们找的temp是位于添加位置的前一个结点，否则插入不了
          HeroNode temp = head;
          boolean flag = false;//flag标志添加的编号是否存在，默认为false
          while (true) {
              if (temp.next == null) {//说明temp已经在链表的最后
                  break;
              }
              if (temp.next.no > heroNode.no) {//位置找到了，就在temp的后面添加
                  break;
              }else if (temp.next.no == heroNode.no){//说明希望添加的HeroNode的编号已经存在
                  flag = true;//说明编号存在
                  break;
              }
              temp=temp.next;
          }
          //判断flag的值
          if (flag){//说明编号存在。不能添加
              System.out.printf("准备插入的Hero的编号 %d 已经存在，不能加入\n",heroNode.no);
          }else {
              //插入到链表中temp的后面
              heroNode.next = temp.next;
              temp.next = heroNode;
          }
      }
      //修改节点的信息，根据no编号来修改，即no编号不能改
      //根据NewHeroNode 的 no来修改即可
      public void update(HeroNode heroNode){
          //判断是否为空
          if (head.next == null){
              System.out.println("链表为空");
              return;
          }
          //找到需要修改的节点，根据no标号
          //先定义一个辅助变量temp
          HeroNode temp = head.next;
          boolean flag = false;
          while (true){
              if (temp == null){
                  break;//已经遍历完链表
              }
              if (temp.no == heroNode.no){//找到了
                  flag =true;
                  break;
              }
              temp = temp.next;
          }
          //根据flag判断是否找到要修改的节点
          if (flag){
              temp.name = heroNode.name;
              temp.nickname = heroNode.nickname;
          } else {//没有找到
              System.out.printf("没有找到编号 %d 的节点，不能修改 \n",heroNode.no);
          }
      }
      //删除节点
      //思路
      //1.head节点不能动，因此我们需要一个temp辅助接点找到待删除的节点的前一个节点
      //2.说明我们在比较时，是temp.next.no 和需要删除的节点的no 比较
      public void delete(int no){
          HeroNode temp = head;
          boolean flag = false;//标志是否找到
          while (true){
              if (temp.next == null){
                  break;
              }
              if (temp.next.no == no){//找到了待删除结点的卡一个节点
                  flag= true;
                  break;
              }
              temp = temp.next;
          }
          if (flag){//找到，可以删除
              temp.next = temp.next.next;
          }else {
              System.out.printf("要删除的 %d 节点不存在",no);
          }
      }
      //显示链表[遍历]
      public void list(){
          //判断链表是否为空
          if(head.next == null){
              System.out.println("链表为空");
              return;
          }
          //因为头节点不能动 ，因此我们需要一个辅助变量来遍历
          HeroNode temp = head.next;
          while (true){
              //判断是否到链表最后
              if (temp == null){
                  break;
              }
              //输出节点信息
              System.out.println(temp);
              //将temp后移
              temp= temp.next;
          }
      }
  
  
  }
  
  class HeroNode{
      public int no;
      public String name;
      public String nickname;
      public HeroNode next;//指向下一个节点
      //构造器
      public HeroNode(int no, String name, String nickname) {
          this.no = no;
          this.name = name;
          this.nickname = nickname;
      }
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "no=" + no +
                  ", name='" + name + '\'' +
                  ", nickname='" + nickname + '\''+
                  '}';
      }
  }
  
  ```

  

单链表面试题

1）求单链表中有效节点的个数

2）查找单链表中的倒数第k个节点

3）单链表的反转

4）从尾到头打印单链表（要求方式1：反向遍历。方式2：Stack栈）

5）合并两个有序的单链表，合并之后的链表依然有序

### 4.3  双向链表

1）遍历方法和单链表一样，只是可以向前，也可以向后

2） 添加（默认添加到双向链表的最后）

​	（1） 先找到双向链表的最后一个节点

​	（2）temp.next = newHeroNode

​	（3）newHeroNode .pre = temp

3)修改思路和单向链表一样

4）删除

​	（1）现为是双向链表，因此，可以实现自我删除某个节点

​	（2）直接找到要删除的这个节点，比如 temp

​	（3）temp.pre.next = temp.next

​	（4）temp.next.pre = temp.pre

:computer:代码演示：

```java
package sanelee.DataStructure;

public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
        HeroNode2 hero5 = new HeroNode2(5, "关胜", "关胜");
//待修改节点
        HeroNode2 heroNode = new HeroNode2(4,"公孙胜","入云龙");

        DoubeLinkedList doubeLinkedList = new DoubeLinkedList();

        doubeLinkedList.add(hero1);
        doubeLinkedList.add(hero2);
        doubeLinkedList.add(hero3);
        doubeLinkedList.add(hero4);

        doubeLinkedList.list();
        System.out.println("---修改后的链表----");
        //修改节点
        doubeLinkedList.update(heroNode);

        doubeLinkedList.list();

        //删除
        doubeLinkedList.delete(3);
        System.out.println("--删除后--");
        doubeLinkedList.list();

        //按顺序添加
        doubeLinkedList.addByOrder(hero3);
        System.out.println("---按顺序添加后--");
        doubeLinkedList.list();

        //按顺序添加到尾部
        doubeLinkedList.addByOrder(hero5);
        System.out.println("---按顺序添加到尾部--");
        doubeLinkedList.list();
    }
}

//创建一个双线链表的类
class DoubeLinkedList {
    //先初始化一个头节点，头节点不要动，不存放具体的数据
    private HeroNode2 head = new HeroNode2(0, "", "");

    //返回头节点
    public HeroNode2 getHead() {
        return head;
    }

    //遍历双向链表的方法
    //显示链表[遍历]
    public void list() {
        //判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为头节点不能动 ，因此我们需要一个辅助变量来遍历
        HeroNode2 temp = head.next;
        while (true) {
            //判断是否到链表最后
            if (temp == null) {
                break;
            }
            //输出节点信息
            System.out.println(temp);
            //将temp后移
            temp = temp.next;
        }
    }

    //添加一个节点到双向链表的最后
    public void add(HeroNode2 heroNode) {
        //因为head节点不能动，因此我们需要一个辅助遍历temp
        HeroNode2 temp = head;
        //遍历链表，找到最后
        while (true) {
            //找到链表的最后
            if (temp.next == null) {
                break;
            }
            //如果没有找到随后，将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向了链表的最后
        //形成一个双向链表
        temp.next = heroNode;
        heroNode.pre = temp;
    }

    //第二种方式再添加英雄时，根据排名将英雄插入到指定位置中
    //（如果有这个排名，则添加失败，并给出提示）
    public void addByOrder(HeroNode2 heroNode) {
        //因为head节点不能动，因此我们需要一个辅助变量temp来帮助找到添加的位置
        //因为单链表，所以我们找的temp是位于添加位置的前一个结点
        HeroNode2 temp = head;
        boolean flag = false;//flag标志添加的编号是否存在，默认为false
        while (true) {
            if (temp.next == null) {//说明temp已经在链表的最后
                break;
            }
            if (temp.next.no > heroNode.no) {//位置找到了，就在temp的后面添加
                break;
            }else if (temp.next.no == heroNode.no){//说明希望添加的HeroNode的编号已经存在
                flag = true;//说明编号存在
                break;
            }
            temp=temp.next;
        }
        //判断flag的值
        if (flag){//说明编号存在。不能添加
            System.out.printf("准备插入的Hero的编号 %d 已经存在，不能加入\n",heroNode.no);
        }else {
            //插入到链表中temp的后面
            heroNode.next = temp.next;
            //如果是最后一个节点就不需要执行下面语句
            if(temp.next!= null){
            heroNode.next.pre=heroNode;
            }
            temp.next = heroNode;
            heroNode.pre=temp;
        }
    }

    //修改一个结点的内容，和单向链表一样
    //修改节点的信息，根据no编号来修改，即no编号不能改
    //根据NewHeroNode 的 no来修改即可
    public void update(HeroNode2 heroNode) {
        //判断是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点，根据no标号
        //先定义一个辅助变量temp
        HeroNode2 temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp == null) {
                break;//已经遍历完链表
            }
            if (temp.no == heroNode.no) {//找到了
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //根据flag判断是否找到要修改的节点
        if (flag) {
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        } else {//没有找到
            System.out.printf("没有找到编号 %d 的节点，不能修改 \n", heroNode.no);
        }
    }

    //从双向链表中删除一个节点
    //说明
    //1 对于双向链表，我们可以直接找到要删除的这个节点
    //2 找到后自我删除即可
    public void delete(int no) {
        //判断当前链表知否为空
        if (head.next == null) {
            System.out.println("链表为空，无法删除");
        }
        HeroNode2 temp = head.next;//辅助变量（指针）
        boolean flag = false;//标志是否找到
        while (true) {
            if (temp.next == null) {//已经到链表最后
                break;
            }
            if (temp.no == no) {//找到了待删除结点的卡一个节点
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {//找到，可以删除
            temp.pre.next = temp.next;
            //如果是最后一个节点，就不需要执行下面的语句，否则会报空指针异常
            if (temp.next != null) {
                temp.next.pre = temp.pre;
            }
        } else {
            System.out.printf("要删除的 %d 节点不存在", no);
        }
    }


}

//定义HeroNode2，每个HeroNode对象就是一个节点
class HeroNode2 {
    public int no;
    public String name;
    public String nickname;
    public HeroNode2 next;//指向下一个节点，默认为null
    public HeroNode2 pre;//指向前一个节点，默认为null

    //构造器
    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}

```

### 4.4. 单项环形链表应用场景（约瑟夫问题）

- 约瑟夫问题	

  - 约瑟夫问题为：设编号为1，2，3，。。。。n的n个人围坐一圈，约定编号为k(1<=k<=n）的人从1开始报数，数到m的那个人出列，他的下一位又开始从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止，由此产生一个出队编号的序列。
  - 提示：用一个不带头结点的循环链表来处理约瑟夫问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始技术，记到m使，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，直到最后一个节点从链表中删除，算法结束

  

  :computer:代码实现：

  ```java
  package sanelee.DataStructure;
  
  public class Josephu {
      public static void main(String[] args) {
  
          //测试构建是否成功
          CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
          circleSingleLinkedList.addBoy(25);
          circleSingleLinkedList.showBoy();
          circleSingleLinkedList.countBoy(1,2,25);
      }
  }
  
  //创建一个环形的单向链表
  class CircleSingleLinkedList{
      //创建一个first节点，当前没有编号
      private Boy first = null;
      //添加Boy节点，构建成一个环形链表
      public void addBoy(int nums){
          //对 nums 进行校验
          if (nums<1){
              System.out.println("nums的值不正确");
              return;
          }
          Boy curBoy = null;//辅助变量，帮助构建环形链表
          for (int i = 1;i<=nums;i++){
              //根据编号，创建Boy节点
              Boy boy = new Boy(i);
              //如果是第一个
              if (i==1){
                  first = boy;
                  first.setNext(first);//构成环
                  curBoy = first;//让curBoy指向第一个小孩
              }else {
                  curBoy.setNext(boy);
                  boy.setNext(first);//构成环
                  curBoy = boy;
              }
          }
      }
      //遍历当前环形链表
      public void showBoy(){
          //判断是否为空
          if (first == null){
              System.out.println("没有任何Boy！！");
              return;
          }
          //因为first不能动，因此我们仍然使用一个辅助指针完成遍历啊
          Boy curBoy = first;
          while (true){
              System.out.printf("小孩的编号:%d \n",curBoy.getNo());
              if (curBoy.getNext() == first){//说明已经遍历完毕
                  break;
              }
              curBoy = curBoy.getNext();//curBoy后移
          }
      }
      //根据用户的输入计算出小孩出圈的顺序
  
      /**
       *
       * @param startNo 表示从第几个小孩开始数数
       * @param countNum 表示数几下
       * @param nums 表示最初由多少个小孩在圈中
       */
      public void countBoy(int startNo,int countNum,int nums){
          //先对数据进行校验
          if (first == null || startNo < 1 || startNo > nums){
              System.out.println("参数输入有误，请重新输入");
          }
          //创建一个辅助指针
          Boy helper = first;
          //需求创建一个辅助指针 helper，事先应该指向环形链表的最后一个节点
          while (true) {
              if (helper.getNext() == first) {
                  break;
              }
              helper = helper.getNext();
          }
          //小孩报数前，先让first和helper 移动 startNo-1次
          for (int j =0 ;j<startNo-1;j++){
              first = first.getNext();
              helper = helper.getNext();
          }
          //当小孩报数时，让first和helper 移动 countNum-1 次,然后出圈
          //这里是一个循环的操作，直到权重只有一个节点
          while (true){
              if (helper == first){//说明圈中只有一个节点
                  break;
              }
              //让first 和 helper 指针同时移动 countNum -1
              for (int j =0 ;j<countNum-1;j++){
                  first = first.getNext();
                  helper = helper.getNext();
              }
              //这时first指向的节点就是要出圈的小孩节点
              System.out.printf("小孩%d出圈\n",first.getNo());
              //这时将first指向的小孩出圈
              first = first.getNext();
              helper.setNext(first);
          }
          System.out.printf("最后留在圈中的小孩编号%d \n",first.getNo());
      }
  }
  //创建一个Boy类，表示一个节点
  class Boy{
      private int no;//编号
      private Boy next;//指向下一个节点。默认为空
      public Boy(int no){
          this.no = no;
      }
  
      public int getNo() {
          return no;
      }
  
      public void setNo(int no) {
          this.no = no;
      }
  
      public Boy getNext() {
          return next;
      }
  
      public void setNext(Boy next) {
          this.next = next;
      }
  }
  
  ```

## 5. 栈（stack）

- 栈是一个先入后出（FILO-First In Last Out）的有序列表
- 栈是研制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（TOP），另一端为固定的一端，称为栈底（Bottom）
- 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

### 5.1. 栈的应用场景

1. 子程序的调用：在跳往子程序前，会先将下一个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
2. 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3. 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）
4. 二叉树的遍历
5. 图形的深度优先（depth_first）搜索法。

### 5.2. 数组模拟栈

实现栈的思路分析

1. 使用数组来模拟栈
2. 定义一个top来表示栈顶，初始化为-1
3. 入栈的操作，当有数据加入到栈时，top++；stack[top] = data;
4. 出栈的操作，int value = stack[top]; top--,return value

:computer:代码实现

```java
package sanelee.DataStructure;

import java.util.Scanner;

public class ArrayStackDemo {
    public static void main(String[] args) {
        //先创建一个ArayStack对象-->表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true;//控制是否退出菜单
        Scanner scanner = new Scanner(System.in);

        while (loop){
            System.out.println("show:表示显示栈");
            System.out.println("exit:退出程序");
            System.out.println("push:表示添加数据到栈（入栈）");
            System.out.println("pop:表示从栈中取出数据（出栈）");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key){
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出战的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }
}

//定义一个类ArrayStack，表示栈
class ArrayStack{
    private int maxSize;//栈的大小
    private int[] stack;//数组 ，数组模拟栈，数据就放在该数组中
    private int top = -1;//top表示栈顶，初始化为-1

    //构造器

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    //栈满
    public boolean isFull(){
        return top == maxSize-1;
    }
    //栈空
    public boolean isEmpty(){
        return top == -1;
    }
    //入栈
    public void push(int value){
        //先判断栈是否满
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈,将栈顶的数据返回
    public int pop(){
        //先判断栈是否空
        if (isEmpty()){
            //抛出异常
            throw new RuntimeException("栈空,没有数据");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈的情况【遍历栈】，遍历时，需要从栈顶开始显示数据
    public void list(){
        if(isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top;i>=0;i--){
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }
}

```

### 5.3. 栈实现综合计算器（中缀表达式）

​	使用栈完成表达式的计算思路

	1. 通过一个index值（索引），来遍历我们的表达式。
 2. 如果我们发现是一个数字，就直接入数栈
 3. 如果发现扫描到的是一个符号，就分如下情况
     	1. 如果发现当前的符号栈为空，就直接入栈
          	2. 如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出两个数，再从符号栈中pop出一个符号，进行运算将得到结果入数栈，然后将当前的操作符入符号栈；如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
4. 当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行。
5. 最后在数栈只有一个数字，就是表达式的结果  

:computer:代码实现

```java
package sanelee.DataStructure;

public class Calculator {
    public static void main(String[] args) {
        //完成表达式的运算
        String expression = "70+2*6-4";
        //创建两个栈，数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量
        int index = 0;//用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' ';//将每次扫描得到的char保存到ch
        String keepNum = "";//用于拼接多位数
        //开始while循环的扫描expression
        while (true) {
            //依次得到expression的每一个字符
            ch = expression.substring(index, index + 1).charAt(0);
            //判断ch是什么，然后做相应处理
            if (operStack.isOper(ch)) {//如果是运算符
                //判断当前的符号栈是否为空
                if (!operStack.isEmpty()) {
                    //如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或等于栈中的操作符，
                    // 就需要从数栈中pop出两个数，再从符号栈中pop出一个符号，进行运算将得到结果入数栈，
                    // 然后将当前的操作符入符号栈；
                    if (operStack.priority(ch)<=operStack.priority(operStack.peak())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1,num2,oper);
                        //把运算结果入数栈
                        numStack.push(res);
                        //然后将当前的操作符入符号栈
                        operStack.push(ch);
                    } else {
                        //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
                        operStack.push(ch);
                    }
                } else {//如果为空，直接入符号栈
                    operStack.push(ch);//1 + 3
                }
            }else {//如果是数，则直接入数栈
//                numStack.push(ch-48);
                //分析思路
                // 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
                // 2. 在处理数时，需要向expression的表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈
                //3. 因此我们需要定义一个字符串变量，用于拼接
                //处理多位数
                keepNum += ch;
                //如果ch已经是expression的最后一位，就直接入栈
                if (index == expression.length()-1){
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) {
                        //如果后一位是运算符，则入栈keepNum = "1" 或者 “123”
                        numStack.push(Integer.parseInt(keepNum));
                        //重要！！！！，keepNum清空
                        keepNum = "";
                    }
                }
            }
            //让index+1，并判断是否扫描到expression的最后
            index++;
            if (index >= expression.length()){
                break;
            }
        }
        //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行。
        while (true){
            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字【结果】
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1,num2,oper);
            numStack.push(res);
        }
        //将数栈最后的数pop出
        int res2 = numStack.pop();
        System.out.printf("表达式%s = %d",expression,res2);
    }
}

    //先创建一个栈
    class ArrayStack2 {
        private int maxSize;//栈的大小
        private int[] stack;//数组 ，数组模拟栈，数据就放在该数组中
        private int top = -1;//top表示栈顶，初始化为-1

        //构造器
        public ArrayStack2(int maxSize) {
            this.maxSize = maxSize;
            stack = new int[this.maxSize];
        }

        //显示栈顶的值
        public int peak(){
            return stack[top];
        }
        //栈满
        public boolean isFull() {
            return top == maxSize - 1;
        }

        //栈空
        public boolean isEmpty() {
            return top == -1;
        }

        //入栈
        public void push(int value) {
            //先判断栈是否满
            if (isFull()) {
                System.out.println("栈满");
                return;
            }
            top++;
            stack[top] = value;
        }

        //出栈,将栈顶的数据返回
        public int pop() {
            //先判断栈是否空
            if (isEmpty()) {
                //抛出异常
                throw new RuntimeException("栈空,没有数据");
            }
            int value = stack[top];
            top--;
            return value;
        }

        //显示栈的情况【遍历栈】，遍历时，需要从栈顶开始显示数据
        public void list() {
            if (isEmpty()) {
                System.out.println("栈空，没有数据");
                return;
            }
            //需要从栈顶开始显示数据
            for (int i = top; i >= 0; i--) {
                System.out.printf("stack[%d]=%d\n", i, stack[i]);
            }
        }

        //返回运算符的优先级，优先级是程序员来确定的，优先级使用数字表示
        //数字越大，则优先级越高
        public int priority(int oper) {
            if (oper == '*' || oper == '/') {
                return 1;
            } else if (oper == '+' || oper == '-') {
                return 0;
            } else {
                return -1;//假定目前的表达式只有+ - * /
            }
        }

        //判断是不是一个运算符
        public boolean isOper(char val) {
            return val == '+' || val == '-' || val == '*' || val == '/';
        }

        //计算方法
        public int cal(int num1, int num2, int oper) {
            int res = 0;//res用于存放计算的结果
            switch (oper) {
                case '+':
                    res = num1 + num2;
                    break;
                case '-':
                    res = num2 - num1;//注意顺序
                    break;
                case '*':
                    res = num1 * num2;
                    break;
                case '/':
                    res = num2 / num1;
                    break;
                default:
                    break;
            }
            return res;
        }
    }




```

### 5.4. 前缀、中缀、后缀表达式（逆波兰表达式）

- 完成一个逆波兰表达式，要求完成如下任务

1. 输入一个逆波兰表达式（后缀表达式），使用栈（Stack），计算其结果

2. 支持小括号和多位数整数，因为这里主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算

3. 思路分析

   1)从左至右扫描，将3和4压入堆栈
   2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈
   3)将5入栈
   4)接下来是x运算符，因此弹出5和7，计算出7x5=35,将35入栈
   5)将6入栈
   6最后是-运算符，计算出35-6的值，即29，由此得出最终结果

4. 代码完成 :computer:

   ```java
   package sanelee.DataStructure;
   
   import java.util.ArrayList;
   import java.util.List;
   import java.util.Stack;
   
   public class PolandNotation {
       public static void main(String[] args) {
           //先定义一个逆波兰表达式
           //(30+4)x5-6 => 30 4 + 5 x 6 -
           //说明，为了方便，逆波兰表达式的数字和符号使用空格隔开
           String suffixExpression = "30 4 + 5 * 6 -";
           //思路：
           //1.先将“3 4 + 5 x 6 -”放到ArrayList中
           //2.将ArrayList传递一个方法，遍历ArrayList 配合栈完成计算
           List<String> rpnList = getListString(suffixExpression);
           System.out.println(rpnList);
           int res = calculate(rpnList);
           System.out.println("计算的结果是" + res);
       }
   
       //将一个逆波兰表达式。依次将数据和运算符放入到ArrayList中
       public static List<String> getListString(String suffixExpression) {
           //将 suffixEcpression 分割
           String[] split = suffixExpression.split(" ");
           List<String> list = new ArrayList<String>();
           for (String ele : split) {
               list.add(ele);
           }
           return list;
       }
       //完成对逆波兰表达式的运算
   
       /**
        * 1)从左至右扫描，将3和4压入堆栈
        * 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈
        * 3)将5入栈
        * 4)接下来是x运算符，因此弹出5和7，计算出7x5=35,将35入栈
        * 5)将6入栈
        * 6）最后是-运算符，计算出35-6的值，即29，由此得出最终结果
        */
   
       public static int calculate(List<String> ls) {
           //创建栈，只需要一个栈即可
           Stack<String> stack = new Stack<>();
           //遍历
           for (String item : ls) {
               //这里使用正则表达式来取出数
               if (item.matches("\\d+")) {//匹配的是多位数
                   //入栈
                   stack.push(item);
               } else {
                   //pop出两个数，并运算，再入栈
                   int num2 = Integer.parseInt(stack.pop());
                   int num1 = Integer.parseInt(stack.pop());
                   int res = 0;
                   if (item.equals("+")) {
                       res = num1 + num2;
                   } else if (item.equals("-")) {
                       res = num1 - num2;
                   } else if (item.equals("*")) {
                       res = num1 * num2;
                   } else if (item.equals("/")) {
                       res = num1 / num2;
                   }else {
                       throw new RuntimeException("运算符有误");
                   }
                   //把res入栈
                   stack.push("" + res);
               }
           }
           //最后留在stack中的数据就是运算结果
           return Integer.parseInt(stack.pop());
       }
   }
   
   ```

   - 中缀表达式转换为后缀表达式              1+((2+3) x 4)-5

      	后缀表达式适合计算式进行计算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发过程中，需要将中缀表达式转成后缀表达式

     具体步骤如下：

     1）初始化两个栈：运算符栈s1和存储中间结果的栈s2

     2）从左至右扫描中缀表达式

     3）遇到操作数时，将其压到s2

     4）遇到运算符时，比较其与s1栈顶运算符的优先级：

     ​		1）如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈

     ​		2）否则，若优先级比栈顶运算符高，也将运算符压入s1

     ​		3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.  1)与s1中新的栈顶运算符相比较；
     
     5）遇到括号时：
     
     ​	1）如果是左括号“（”，则直接压入s1
     
     ​	2）如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 
     
     6）重复步骤2至5，知道表达式的最右边
     
     7）将s1中剩余的运算符依次弹出并压入s2
     
     8）依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式



## 6. 递归

1. 递归的概念

   简单地说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。

2. 递归用于解决什么样的问题

   1. 各种数学问题如：八皇后问题，汉诺塔，阶乘问题等
   2. 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等
   3. 将用栈解决的问题用递归替代，使得代码简洁

3. 递归调用机制：
   1. 当程序执行到一个方法时，就会开辟一个独立的空间（栈）。
   2. 每个空间的数据（局部变量）是独立的。

4. 递归需要遵守的重要原则
   1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
   2. 方法的局部变量是独立的，不会相互影响
   3. 如果方法中使用的是引用类型的变量（比如数组），就会共享该引用类型的数据。
   4. 递归必须向退出递归的条件逼近，否则就是无限递归
   5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

5. 递归迷宫问题

   :computer: 代码实现

   ```java
   package sanelee.DataStructure.recursion;
   
   public class MiGong {
       public static void main(String[] args) {
           //先创建一个二维数组模拟迷宫
           //地图
           int[][] map = new int[8][7];
           //使用1表示墙
           //上下全部置为1
           for (int i =0;i<7;i++){
               map[0][i] = 1;
               map[7][i] = 1;
           }
           //左右全部置为1
           for (int i =0;i<8;i++){
               map[i][0] = 1;
               map[i][6] = 1;
           }
           //设置挡板
           map[3][1] = 1;
           map[3][2] = 1;
   
   
           //输出地图
           for (int i = 0;i<8;i++){
               for (int j = 0;j<7;j++){
                   System.out.print(map[i][j]+" ");
               }
               System.out.println();
           }
           //使用递归回溯给小球找路
           setWay(map,1,1);
           System.out.println("小球走过，并标识过的地图");
           //输出新的地图，小球走过，并标识过的地图
           for (int i = 0;i<8;i++){
               for (int j = 0;j<7;j++){
                   System.out.print(map[i][j]+" ");
               }
               System.out.println();
           }
       }
       //使用递归回溯来给小球找路
       //说明 1.map 表示地图
       // 2.i,j 表示从地图的哪个位置开始出发（1，1）
       // 3.如果小球能到map[5][6]位置，则说明通路找到
       // 4.约定：当map[i][j]为0表示该点没有走过，当为1表示墙，2表示通路，可以走，3表示该位置已经走过但是走不通
       // 5.策略：下->右->上->左 ,如果该点走不通则回溯
   
       /**
        *
        * @param map 表示地图
        * @param i 从那个位置开始的
        * @param j
        * @return 如果找到通路，就返回true否则返回false
        */
       public static boolean setWay(int[][] map,int i,int j){
           if (map[6][5] == 2){//通路已经找到
               return true;
           }else {
               if (map[i][j] == 0){//如果当前这个点还没走过
                   //按照策略：下->右->上->左
                   map[i][j] = 2; //假定该点可以走通
                   if (setWay(map, i-1, j)){//向上走
                       return true;
                   } else if (setWay(map, i, j+1)){//向右走
                       return true;
                   } else if (setWay(map, i+1, j)){//向下走
                       return true;
                   } else if (setWay(map, i, j-1)) {//向左走
                       return true;
   
   
                   } else {
                       //说明该点是死路
                       map[i][j] = 3;
                       return false;
                   }
               }else {//如果map[i][j] ！= 0，可能是1，2，3
                   return false;
               }
           }
       }
   }
   
   ```

   
   
6. 递归-八皇后问题（回溯算法）

   1. 问题介绍：八皇后问题是一个古老而著名的问题，是回溯算法的经典案例：在8 x 8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问由多少种摆法（92）.

   2. 算法思路分析：

      1. 第一个皇后先放第一列
      2. 第二个皇后放在第二行第一列，然后判断是否OK，如果不OK，继续放在第二列、第三列、一次把所有列都放完，找到一个合适的
      3. 继续第三个皇后，还是第一列、第二列----直到第八个皇后也能放在一个不冲突的位置，算是找到了一个正确解
      4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后放到第一列的所有正确界全部得到
      5. 然后回头继续第一个皇后放第二列，后面继续循环执行1，2，3，4的步骤

   3. :computer:代码实现：

      

      ```java
      package sanelee.DataStructure.recursion;
      
      public class Queen8 {
          //定义一个max表示一共有多少个皇后
          int max = 8;
          //定义数组array，保存皇后放置位置的结果，比如arr = {0，4，7，5，2，6，1，3}
          int[] array = new int[max];
          static int count = 0;
          public static void main(String[] args) {
              //测试
              Queen8 queen8 = new Queen8();
              queen8.check(0);
              System.out.println(count);
          }
      
          //编写一个方法放置第n个皇后
          private void check(int n){
              if (n == max){//n = 8,其实8个皇后就依然放好了
                  print();
                  return;
              }
              //依次放入皇后，并判断是否冲突
              for (int i = 0;i<max;i++){
                  //先把当前这个皇后放到该行的第一列
                  array[n] = i;
                  //判断当放置第n个皇后到i列时，是否冲突
                  if (judge(n)){//不冲突
                      //接着放n+1个皇后，即开始递归
                      check(n+1);
                  }
                  //如果冲突就继续执行array[n] = i；即将第n个皇后放置在本行的后移一个位置
              }
          }
      
          /**
           * 检测是否和前面已经摆放的皇后冲突
           * @param n 表示第n个皇后
           * @return
           */
          private boolean judge(int n){
              for (int i =0;i<n;i++){
                  //1.array[i] == array[n] 判断是否在同一列
                  //2.Math.abs(n-i) == Math.abs(array[n]-array[i]) 判断是否在同一斜线
                  if (array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n]-array[i])){
                      return false;
                  }
              }
              return true;
          }
          //写一个方法，可以将皇后摆放的位置输出
          private void print(){
              for (int i = 0;i<array.length;i++){
                  System.out.print(array[i]+" ");
              }
              System.out.println();
              count++;
          }
      }
      
      ```


## 7.排序算法

常见的算法时间复杂度由小到大依次为：O(1)<O(log2n)<O(n)<O(nlog2n)<O(n2)<O(n3)<O(nk)<O(2n)

### 1. 冒泡排序

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使数值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。时间复杂度为O(n^2)

:computer:示例代码： 

```java
package sanelee.DataStructure.sort;


import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class BubbleSort {
    public static void main(String[] args) {
        int arry[] = {3, 9, -1, 10, 20};
        System.out.println("排序前");
        System.out.println(Arrays.toString(arry));
//        //测试一下速度，给80000个数据
//        int[] arry = new int[80000];
//        for (int i = 0;i<80000;i++){
//            arry[i] = (int)(Math.random()*8000000);
//        }
//        Date date1 = new Date();
//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//        String date1Str = simpleDateFormat.format(date1);
//        System.out.println("排序前的时间："+ date1Str);
        bubbleSort(arry);
        System.out.println("排序后");
        System.out.println(Arrays.toString(arry));
//        Date date2 = new Date();
//        String date2Str = simpleDateFormat.format(date2);
//        System.out.println("排序后的时间："+ date2Str);

    }

    //排序算法封装
    public static void bubbleSort(int[] arry) {
        int temp = 0;//临时变量
        boolean flag = false;//标识符变量，表示是否进行过交换
        for (int j = 0; j < arry.length - 1; j++) {
            for (int i = 0; i < arry.length - 1 - j; i++) {
                //如果前面的数比后面的数大，则交换
                if (arry[i] > arry[i + 1]) {
                    flag = true;
                    temp = arry[i];
                    arry[i] = arry[i + 1];
                    arry[i + 1] = temp;
                }
            }
            //System.out.println("第" + (j + 1) + "趟排序后的数组");
            //System.out.println(Arrays.toString(arry));
            if (!flag) {//一次交换都没有发生
                break;
            } else {
                flag = false;//重置flag,进行下次判断
            }
        }
//        System.out.println("最终的排序结果");
//        System.out.println(Arrays.toString(arry));
    }
}

```

### 2. 选择排序

选择式排序也属于内部排序法，是从欲排序的数据中，按制定的规则选出某一元素，再依规定交换位置后达到排序的目的。

**基本思想**：第一次从arr[0] ~ arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1] ~ arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2] ~ arr[n-1]中选取最小值，与arr[2]交换，。。。。第i次从arr[i-1] ~ arr[n-1]中选取最小值，与arr[i-1]交换，。。。，第n-1次从arr[n-2] ~ arr[n-1]中选取最小值，与arr[n-2]交换，总共会通过n-1次，得到一个按排序码从小到大排列的有序序列。时间复杂度为O(n^2)

:computer:示例代码

```java
package sanelee.DataStructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;


public class SelectSort {
    public static void main(String[] args) {
        int arr[] = {101,34,119,1};
                //测试一下速度，给80000个数据
//        int[] arr = new int[80000];
//        for (int i = 0;i<80000;i++){
//            arr[i] = (int)(Math.random()*8000000);
//        }
//        Date date1 = new Date();
//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//        String date1Str = simpleDateFormat.format(date1);
//        System.out.println("排序前的时间："+ date1Str);
        selectSort(arr);
//        Date date2 = new Date();
//        String date2Str = simpleDateFormat.format(date2);
//        System.out.println("排序后的时间："+ date2Str);
        System.out.println(Arrays.toString(arr));
    }
    public static void selectSort(int[] arr){
        int index = 0;

        for (int i=0;i<arr.length-1;i++){
            int min = arr[i];
            for (int j = i;j<arr.length;j++){
                if (arr[j]<min){
                    min = arr[j];
                    index = j;
                }
            }
            if (index != i) {
                arr[index] = arr[i];
                arr[i] = min;
            }
        }
    }
}

```

### 3.插入排序

插入排序属于内部排序算法，是对欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

基本思路：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表

:computer:示例代码：

```java
package sanelee.DataStructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class InsertionSort {
    public static void main(String[] args) {
//        int arr[] = {101,34,119,1,5,3,8};
        int[] arr = new int[80000];
        for (int i = 0;i<80000;i++){
            arr[i] = (int)(Math.random()*80000);
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("while语句排序前的时间："+ date1Str);
        insertSort(arr);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("while语句排序后的时间："+ date2Str);
 

//        Date date3 = new Date();
//        String date3Str = simpleDateFormat.format(date3);
//        System.out.println("for语句排序前的时间："+ date3Str);
//        insertSortFor(arr);
//        Date date4 = new Date();
//        String date4Str = simpleDateFormat.format(date4);
//        System.out.println("for语句排序后的时间："+ date4Str);

//        System.out.println(Arrays.toString(arr));
    }
    public static void insertSort(int[] arr){
        for (int i = 1;i<arr.length;i++){
            int InsertValue = arr[i];
            int InsertIndex = i-1;
//            for (int j =i-1;j>=0;j--){
//                if (arr[j]>InsertValue){
//                    arr[j+1] = arr[j];
//                    arr[j] = InsertValue;
//                }
//            }
            while (InsertIndex >=0 && InsertValue<arr[InsertIndex]){
                arr[InsertIndex+1] = arr[InsertIndex];
                InsertIndex--;
            }
            if (InsertIndex +1 != i) {
                arr[InsertIndex + 1] = InsertValue;
            }
        }
    }
    public static void insertSortFor(int[] arr){
        for (int i = 1;i<arr.length;i++){
            int InsertValue = arr[i];
            int InsertIndex = i-1;
            for (int j =i-1;j>=0;j--){
                if (arr[j]>InsertValue){
                    arr[j+1] = arr[j];
                    arr[j] = InsertValue;
                }
            }
        }
    }
}

```

### 4.希尔排序

希尔排序也是一种*插入排序*，它是简单插入排序经过改进之后的一个更高的版本，也称为*缩小增量排序*。

希尔排序是把计录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰好被分成一组，算法终止。

:computer:示例代码：

```java
package sanelee.DataStructure.sort;

import java.util.Arrays;

public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {8,9,1,7,2,3,5,4,6,0};
//        int[] arr = new int[80000];
//        for (int i = 0; i < 80000; i++) {
//            arr[i] = (int) (Math.random() * 80000000);
//        }
//        Date date1 = new Date();
//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//        String date1Str = simpleDateFormat.format(date1);
//        System.out.println("排序前的时间：" + date1Str);
        shellSort2(arr);
//        Date date2 = new Date();
//        String date2Str = simpleDateFormat.format(date2);
//        System.out.println("排序后的时间：" + date2Str);
        System.out.println(Arrays.toString(arr));
    }

    public static void shellSort(int[] arr) {
        int temp = 0;
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                //遍历各组中所有的元素
                for (int j = i - gap; j >= 0; j -= gap) {
                    //如果当前元素大于加上步长后的元素，则交换
                    if (arr[j] > arr[j + gap]) {
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
        }
    }

    //对交换式的希尔排序进行优化-》移位法
    public static void shellSort2(int[] arr) {
        //增量gap，并逐步缩小增量
        for (int gap = arr.length / 2; gap > 0; gap /= 2) {
            //从第gap个元素开始，逐个对其所在的这个组进行直接插入排序
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];
                if (arr[j] < arr[j - gap]) {
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                        //移动
                        arr[j] = arr[j-gap];
                        j -= gap;
                    }
                    //当退出while后，就给temp找到了插入的位置
                    arr[j]=temp;
                }
            }
        }
    }
}

```

### 5. 快速排序

快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据都变成有序序列。时间复杂度O(nlogn)

:computer:示例代码：

```java
package sanelee.DataStructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class QuickSort {
    public static void main(String[] args) {
//        int[] arr = {12,44,21,234,65780,12,237,12,1};
        int[] arr = new int[8000000];
        for (int i = 0; i < 8000000; i++) {
            arr[i] = (int) (Math.random() * 800000000);
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间：" + date1Str);
        quickSort(arr, 0, arr.length - 1);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间：" + date2Str);
//        System.out.println(Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int left, int right) {
        int l = left;//左下标
        int r = right;//右下标
        //中轴值
        int pivot = arr[(left + right) / 2];
        int temp = 0;//临时变量

        while (l < r) {
            while (arr[l] < pivot) {
                l++;
            }
            while (arr[r] > pivot) {
                r--;
            }
            //如果l >= r说明pivot的左右两边的值已经按照左边全部是小于等于pivot的值，有便全部是大于等于pivot的值
            if (l >= r) {
                break;
            }
            //交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;
            //如果交换完后，发现arr[l]== pivot的值，前移
            if (arr[l] == pivot) {
                r--;
            }
            //如果交换完后，发现arr[r]== pivot的值，后移
            if (arr[r] == pivot) {
                l++;
            }
        }
        //如果l==r，必须l++,r__,否则会出现栈溢出
        if (l == r) {
            l += 1;
            r -= 1;
        }
        //向左递归
        if (left < r) {
            quickSort(arr, left, r);
        }
        //向右递归
        if (right > l) {
            quickSort(arr, l, right);
        }
    }
}

```

### 6. 归并排序

归并排序（MERGE-SORT）是利用归并的思想实现的排序算法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案修补在一起，即分而治之）

:computer:示例代码

```java
package sanelee.DataStructure.sort;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/4/22
 **/
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {8, 4, 5, 7, 1, 3, 6, 2};
//        int[] arr = new int[8000000];
//        for (int i = 0; i < 8000000; i++) {
//            arr[i] = (int) (Math.random() * 800000000);
//        }
//        Date date1 = new Date();
//        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//        String date1Str = simpleDateFormat.format(date1);
//        System.out.println("排序前的时间：" + date1Str);
        int temp[] = new int[arr.length];
        mergeSort(arr, 0, arr.length - 1, temp);

//        Date date2 = new Date();
//        String date2Str = simpleDateFormat.format(date2);
//        System.out.println("排序后的时间：" + date2Str);
        System.out.println(Arrays.toString(arr));
    }

    //分+合的方法
    public static void mergeSort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = (left + right) / 2;//中间的索引
            //向左递归进行分解
            mergeSort(arr, left, mid, temp);
            //向右递归进行分解
            mergeSort(arr, mid + 1, right, temp);
            //到合并
            merge(arr, left, mid, right, temp);
        }
    }

    /**
     * 合并的方法
     *
     * @param arr   排序的原始数组
     * @param left  左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp  做中转的数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;//初始化i,左边有序序列的初始索引
        int j = mid + 1;//初始化j，表示右边有序序列的初始索引
        int t = 0;//指向temp数组的当前索引
        //1.先把左右两边的数据按规则填充到temp数组
        //直到左右两边有一边处理完毕为止
        while (i <= mid && j <= right) {
            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
            //即将左边的当前元素，拷贝到temp
            //然后将左边的当前元素，拷贝到temp数组
            if (arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t += 1;
                i += 1;
            } else {//反之，将右边的有序序列的当前元素拷贝到temp数组
                temp[t] = arr[j];
                t += 1;
                j += 1;
            }
        }
        //2.把有剩余数据的一边的数据一次全部按顺序填充到temp
        while (i <= mid) {//说明左边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[i];
            t += 1;
            i += 1;
        }
        while (j <= right) {//说明右边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[j];
            t += 1;
            j += 1;
        }
        //3.将temp数组的元素拷贝到arry
        //注意：并不是每次都拷贝所有
        t = 0;
        int tempLeft = left;
        while (tempLeft <= right) {
            arr[tempLeft] = temp[t];
            t += 1;
            tempLeft += 1;
        }

    }
}

```

### 7. 基数排序

基数排序（radix sort）属于“分配式排序”，又称“桶子法”或bin sort，顾名思义，它是通过键值的个各位的值，将要排序的元素分配至某些“桶”中，达到排序的作用

基数排序法是属于稳定性的排序，基数排序法是效率高的稳定性排序法

**基本思想：** 将所有带比较熟制统一为同样的数位长度，数位较短的数前面补零。然后从低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序数列。

**基数排序说明**

1. 基数排序是对传统桶排序的扩展，速度很快
2. 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError
3. 基数排序是稳定的

:computer:示例代码

```java
package sanelee.DataStructure.sort;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/4/24
 **/
public class RadixSort {
    public static void main(String[] args) {
        int[] arr = {53, 3, 542, 748, 14, 214};
        radixSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    //基数排序方法
    public static void radixSort(int[] arr) {
        //根据前面的推导过程
        //得到数组中最大的数的位数
        int max =arr[0];//假设第一个数就是最大数
        for (int i = 0; i<arr.length;i++){
            if (arr[i]>max){
                max =arr[i];
            }
        }
        //得到最大数的位数
        int maxLength = (max + "").length();

        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组
        //1.二维数组包含10个一维数组
        //2.为了防止在放入数的时候数据溢出，则每个一维数组大小定为arr。length
        int[][] bucket = new int[10][arr.length];
        //为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶每次放入的数据个数
        int[] bucketElementCounts = new int[10];
        //使用循环将代码处理
        for (int i = 0,n=1;i<maxLength;i++,n*=10){
            //针对每个元素对应位进行排序
            for (int j = 0; j < arr.length; j++) {
                //去除每个元素的个位数
                int digitOfElement = arr[j]/n % 10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
            int index = 0;
            //遍历每一个桶，并将桶中的数据放入到原数组
            for (int k = 0;k<bucketElementCounts.length;k++){
                //如果桶中有数据，我们才放入到原数组
                if (bucketElementCounts[k]!=0){
                    //循环该桶
                    for (int l =0;l<bucketElementCounts[k];l++){
                        arr[index++]=bucket[k][l];
                    }
                }
                bucketElementCounts[k]=0;
            }
        }


//
//        //第一轮
//        for (int j = 0; j < arr.length; j++) {
//            //去除每个元素的个位数
//            int digitOfElement = arr[j] % 10;
//            //放入到对应的桶中
//            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
//            bucketElementCounts[digitOfElement]++;
//        }
//        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
//        int index = 0;
//        //遍历每一个桶，并将桶中的数据放入到原数组
//        for (int k = 0;k<bucketElementCounts.length;k++){
//            //如果桶中有数据，我们才放入到原数组
//            if (bucketElementCounts[k]!=0){
//                //循环该桶
//                for (int l =0;l<bucketElementCounts[k];l++){
//                    arr[index++]=bucket[k][l];
//                }
//            }
//            bucketElementCounts[k]=0;
//        }
//        //==================================
//        //第二轮
//        for (int j = 0; j < arr.length; j++) {
//            //去除每个元素的十位数
//            int digitOfElement = arr[j] /10 % 10;
//            //放入到对应的桶中
//            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
//            bucketElementCounts[digitOfElement]++;
//        }
//        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
//        index = 0;
//        //遍历每一个桶，并将桶中的数据放入到原数组
//        for (int k = 0;k<bucketElementCounts.length;k++){
//            //如果桶中有数据，我们才放入到原数组
//            if (bucketElementCounts[k]!=0){
//                //循环该桶
//                for (int l =0;l<bucketElementCounts[k];l++){
//                    arr[index++]=bucket[k][l];
//                }
//            }
//            bucketElementCounts[k]=0;
//        }
//        //==================================
//        //第三轮
//        for (int j = 0; j < arr.length; j++) {
//            //去除每个元素的百位数
//            int digitOfElement = arr[j] /100 % 10;
//            //放入到对应的桶中
//            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
//            bucketElementCounts[digitOfElement]++;
//        }
//        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
//        index = 0;
//        //遍历每一个桶，并将桶中的数据放入到原数组
//        for (int k = 0;k<bucketElementCounts.length;k++){
//            //如果桶中有数据，我们才放入到原数组
//            if (bucketElementCounts[k]!=0){
//                //循环该桶
//                for (int l =0;l<bucketElementCounts[k];l++){
//                    arr[index++]=bucket[k][l];
//                }
//            }
//            bucketElementCounts[k]=0;
//        }
    }
}

```





## 8. 查找算法

### 1.线性查找算法

:computer:示例代码：

```java
package sanelee.DataStructure.search;

/**
 * @author sanelee
 * @date 2020/4/25
 **/
public class Seqsearch {
    public static void main(String[] args) {
         int[] arr = {1,9,11,-1,34,89};
         int index = seqSearch(arr,12);
         if (index == -1){
             System.out.println("没有找到");
         }else {
             System.out.println("找到，下标为"+index);
         }
    }
    public static int seqSearch(int[] arr ,int value){
        //线性查找是逐一比对，发现有相同值就返回下标
        for (int i =0;i<arr.length;i++){
            if (arr[i] == value){
                return i;
            }
        }
        return -1;
    }
}

```



### 2.二分查找

**思路分析**：

1. 首先确定该数组的中间下标 mid=(left+right)/2

2. 然后让需要查找的数value和arr[mid]比较

   2.1 如果findVal>arr[mid],说明要查找的数在mid的右边，因此需要递归地向右查找

   2.2 如果findVal<arr[mid],说明要查找的数在mid的左边，因此需要递归的向左查找

   2.3 findVal==arr[mid],说明找到，就返回

   //什么时候结束递归

   1）找到就结束递归

   2）递归完整个数组仍然没有找到,也需要结束递归，当left>right就需要退出

:computer:示例代码：

```java
package sanelee.DataStructure.search;

/**
 * @author sanelee
 * @date 2020/4/25
 **/

import java.util.ArrayList;
import java.util.List;

/***
 * 使用二分查找的前提是该数组是有序的
 */
public class BinarySearch {
    public static void main(String[] args) {
        int arr[] = {1, 8, 10, 89, 123, 1000, 1234};
        int resIndex = binarySearch(arr, 0, arr.length - 1, 123);
        List<Integer> list = binarySearch2(arr, 0, arr.length - 1, 123);
        System.out.println("resIndex=" + resIndex);
        System.out.println("resIndexList=" + list);
    }

    /**
     * @param arr     数组
     * @param left    左边的索引
     * @param right   右边的索引
     * @param findVal 要查找的值
     * @return 如果找到就返回下标，如果没有找到就返回-1
     */
    public static int binarySearch(int[] arr, int left, int right, int findVal) {
        //如果没有找到就退出递归
        if (left > right) {
            return -1;
        }

        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (findVal > midVal) {//向右递归
            return binarySearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) {//向左递归
            return binarySearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }

    }


    public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal) {
        //如果没有找到就退出递归
        if (left > right) {
            return new ArrayList<Integer>();
        }

        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (findVal > midVal) {//向右递归
            return binarySearch2(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) {//向左递归
            return binarySearch2(arr, left, mid - 1, findVal);
        } else {
            List<Integer> resIndexList = new ArrayList<>();
            int temp = mid - 1;
            while (true) {
                if (temp < 0 || arr[temp] != findVal) {//退出
                    break;
                }
                resIndexList.add(temp);
                temp -= 1;//左移
            }
            resIndexList.add(mid);
            temp = mid + 1;
            while (true) {
                if (temp > arr.length || arr[temp] != findVal) {
                    break;
                }
                resIndexList.add(temp);
                temp += 1;//右移
            }
            return resIndexList;
        }

    }
}

```

### 3. 插值查找

插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。将折半查找中的求mid索引的公式改为
$$
mid = left+\frac{key-arr[left]}{arr[right]+arr[left]}(right-left)
$$
注意事项：对于数据量大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快。关键字分布不均匀的情况下，该方法不一定比折半查找要好

:computer:示例代码;

```java
package sanelee.DataStructure.search;

/**
 * @author sanelee
 * @date 2020/4/25
 **/
public class InsertValueSearch {
    public static void main(String[] args) {
        int arr[] = new int[100];
        for (int i = 0; i < 100; i++) {
            arr[i] = i + 1;
        }
        int resIndex = insertValueSearch(arr,0,arr.length-1,100);
        System.out.println("resIndex="+resIndex);
    }

    /**
     * @param arr     数组
     * @param left    左边索引
     * @param right   右边索引
     * @param findVal 查找值
     * @return
     */
    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
        //求出mid
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal > midVal){//向右递归
            return insertValueSearch(arr,mid +1,right,findVal);
        }else if (findVal<midVal){//向左递归
            return insertValueSearch(arr,left,mid-1,findVal);
        }else {
            return mid;
        }
    }
}

```

### 4. 斐波那契查找

原理：斐波那契查找原理与前两种相似，仅仅改变了中间节点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即 mid = low + F ( k - 1 ) - 1 (F代表斐波那契数列)

:computer:代码示例：

```java
package sanelee.DataStructure.search;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/4/26
 **/
public class FibonacciSearch {
    public static int maxSize = 20;

    public static void main(String[] args) {
        int[] arr = {1, 8, 10, 89, 1000, 1234};
        System.out.println("index="+fibSearch(arr,1234));
    }

    //用非递归的方式得到一个斐波那契数列
    public static int[] fib() {
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }

    /**
     * 编写斐波那契查找算法
     * 非递归
     *
     * @param a   数组
     * @param key 我们需要查找的关键码（值）
     * @return 返回对应的下标
     */
    public static int fibSearch(int[] a, int key) {
        int low = 0;
        int high = a.length - 1;
        int k = 0;//表示斐波那契分割数值的下标
        int mid = 0;
        int f[] = fib();//获取到斐波那契数列
        //获取到斐波那契分割数值的下标
        while (high > f[k] - 1) {
            k++;
        }
        //因为f[k]可能大于数组的长度，因此需要使用一个Arrays类，构造一个新的数组，并指向temp
        //不足的部分会使用0填充
        int[] temp = Arrays.copyOf(a, f[k]);
        //实际上需求使用a数组最后的数填充temp
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = a[high];
        }
        while (low <= high) {
            mid = low + f[k - 1] - 1;
            if (key < temp[mid]) {//应该向数组的左面查找
                high = mid - 1;
                k--;
            } else if (key > temp[mid]) {//应该向数组的右面查找
                low = mid + 1;
                //为什么是k -= 2；
                //1.全部元素 = 前面元素+后面元素
                //2.f[k] = f[k-1] + f[k-2]
                //3.因为后面还有f[k-2]个元素 ，所以可以继续拆分f[k-2] = f[k-3]+f[k-4]
                //4.即在f[k-2]的前面可以继续进行查找k-=2;
                //5.即下次循环mid = f[k-2-1]-1
                k -= 2;
            } else {//找到,需要确定返回的是哪个下标
                if (mid <= high) {
                    return mid;
                } else {
                    return high;
                }
            }
        }
        return -1;
    }
}
```



### 哈希表

散列表（Hash table，也叫哈希表），是根据关键码值（Key Value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表

## 9. 树

为什么需要树这种数据结构

1）数组存储方式的分析

优点：通过下标的方式访问元素，速度快，对于有序数组，还可以使用二分查找提高检索速度

缺点：如果要检索具体的某个值，或者插入到具体的位置（按一定顺序）会整体移动，效率低

2）链式存储方式的分析

优点：在一定程度上对数组存储方式有优化

缺点：再进行检索时，效率仍然低下

3）树存储方式的分析

能提高数据存储，读取的效率，比如利用二叉排序树，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

### 1.二叉树

二叉树的概念：

1）树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树

2） 二叉树的子节点分为左节点和右节点。

3）如果该二叉树的所有叶子节点都在最后一层，并且节点总数=2^n-1，n为层数，则称为满二叉树

4）如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续。倒数第二层的叶子节点在右边连续，我们称之为完全二叉树



>==分析二叉树的前序、中序、后序的遍历步骤==
>
>1. 创建一个二叉树
>2. 前序遍历
>   1. 先输出当前节点（初始的时候是root节点）
>   2. 如果左子节点不为空，则递归继续前序遍历
>   3. 如果右子节点不为空，则递归继续前序遍历
>3. 中序遍历
>   1. 如果当前节点的左子节点不为空，则递归中序遍历
>   2. 输出当前节点
>   3. 如果当前节点的右子节点不为空，则递归中序遍历
>4. 后序遍历
>   1. 如果当前节点的左子节点不为空，则递归后序遍历
>   2. 如果当前节点的右子节点不为空，则递归后序遍历
>   13. 输出当前节点

:computer:代码实现：

```java
package sanelee.DataStructure.binaryTree;

/**
 * @author sanelee
 * @date 2020/5/4
 **/
public class BinaryTreeDemo {
    public static void main(String[] args) {

        //创建需要的节点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode heroNode2 = new HeroNode(2, "吴用");
        HeroNode heroNode3 = new HeroNode(3, "卢俊义");
        HeroNode heroNode4 = new HeroNode(4, "林冲");
        HeroNode heroNode5 = new HeroNode(5, "关胜");

        //说明，先手动建立二叉树，后面学习递归的方式创建二叉树
        root.setLeft(heroNode2);
        root.setRight(heroNode3);
        heroNode3.setRight(heroNode4);
        heroNode3.setLeft(heroNode5);

        //创建一个二叉树
        BinaryTree binaryTree = new BinaryTree(root);
//        binaryTree.setRoot(root);
        //测试
        System.out.println("前序遍历");//1,2,3,5,4
        binaryTree.preOrder();

        System.out.println("中序遍历");//2,1,5,3,4
        binaryTree.infixOrder();

        System.out.println("后序遍历");//2,5,4,3,1;
        binaryTree.postOrder();

    }
}
//定义BinaryTree 二叉树
class BinaryTree{
    private HeroNode root;

    public BinaryTree(HeroNode root) {
        this.root = root;
    }

    public BinaryTree() {
    }

    public HeroNode getRoot() {
        return root;
    }

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
}
//先创建HeroNode节点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;//默认null
    private HeroNode right;//默认null

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    //编写前序遍历的方法
    public void preOrder(){
        System.out.println(this);//先输出父节点
        //递归向左子树前序遍历
        if (this.left != null){
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if (this.right != null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树中序遍历
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);//先输出父节点
        //递归向右子树中序遍历
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树后序遍历
        if (this.left != null){
            this.left.postOrder();
        }
        //递归向右子树后序遍历
        if (this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);//输出父节点
    }
}

```





>==使用前序、中序、后序的方式来查询指定的节点==
>
>**前序查找思路**
>
>1. 先判断当前节点的no是否等于要查找的
>2. 如果相等，则返回当前节点
>3. 如果不等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找
>4. 如果左递归前序查找，找到节点，则返回，否则继续判断，当前节点的右子节点是否为空，如果不空，则继续向右递归前序查找
>
>**中序查找思路**
>
>1. 判断当前节点的左子节点是否为空，如果不为空，则递归中序查找
>2. 如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点，否则继续进行右递归的中序查找
>3. 如果右递归中序查找，找到就返回，否则就返回null
>
>**后序查找思路**
>
>1. 判断当前节点的左子节点是否为空，如果不为空，则递归后续查找
>2. 如果找到就返回，如果没有找到，就判断当前节点的右子节点是否为空，如果不为空，则右递归进行后续查找，如果找到就返回
>3. 如果没有找到就和当前节点进行比较，如果是就返回，否则就返回null

:computer:代码实现

```java
 /**
     * //前序遍历查找
     * @param no 查找no
     * @return 如果找到就返回该Node，如果没有找到返回null
     */
    public HeroNode proOrderSearch(int no){
        System.out.println("进入前序遍历");
        //比较当前节点是不是
        if (this.no == no){
            return this;
        }
        HeroNode resNode = null;
        //递归向左子树前序查找
        if (this.left != null){
            resNode = this.left.proOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }
        //递归向右子树前序查找
        if (this.right != null){
            resNode = this.right.proOrderSearch(no);
        }
        return resNode;
    }

    /***
     * 中序遍历查找
     * @param no 查找no
     * @return 如果找到就返回该Node，如果没有找到返回null
     */
    public HeroNode infixOrderSearch(int no){

        HeroNode resNode = null;
        //递归向左子树前序查找
        if (this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }
        System.out.println("进入中序查找");
        //比较当前节点是不是
        if (this.no == no){
            return this;
        }
        //递归向右子树前序查找
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }
    /***
     * 后序遍历查找
     * @param no 查找no
     * @return 如果找到就返回该Node，如果没有找到返回null
     */
    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        //递归向左子树前序查找
        if (this.left != null){
            resNode = this.left.postOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }

        //递归向右子树前序查找
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }
        //比较当前节点是不是
        System.out.println("进入后序查找");
        if (this.no == no){
            return this;
        }
        return resNode;
    }
```



>完成删除节点的操作
>
>规定：
>
>1. 如果删除的节点是叶子节点，则删除该节点
>2. 如果删除的节点是非叶子节点，则删除该子树
>
>思路：
>
>首先：考虑如果树是空树root，如果只有一个root结点，则等价将二叉树置空
>
>然后：
>
>1. 因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点
>2. 如果当前的节点的左子节点不为空，并且左子节点就是要删除节点，就将this.left=null;并且就返回（结束递归删除）
>3. 如果当前节点的右子节点不为空，并且右子节点就是要删除节点，就将this.right = null;并且返回（结束递归删除）。
>4. 如果第二步和第三步没有删除节点，那么我们就要向左子树进行递归删除
>5. 如果第四步也没有删除结点，则应当向右子树进行递归删除

:computer:代码示例：

```java
 /**
     * 递归删除节点
     * 1. 如果删除的节点是叶子节点，则删除该节点
     * 2. 如果删除的节点是非叶子节点，则删除该子树
     * @param no
     */
    public void delNode(int no){
        if (this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if (this.left != null){
            this.left.delNode(no);
        }
        if (this.right != null){
            this.right.delNode(no);
        }

    }
```

#### 顺序存储二叉树

概念：从数据存储来看，数组存储方式和树的存储方式可以互相转换，即数组可以转换成树，树也可以转换成数组 

要求：在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

特点：

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子节点为2*n+1
3. 第n个元素的右子节点为2*n+2
4. 第n个元素的父节点为（n-1）/2
5. n:表示二叉树中的第几个元素

:computer:示例代码：

```java
package sanelee.DataStructure.binaryTree;

/**
 * @author sanelee
 * @date 2020/5/6
 **/
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7};
        //创建一个ArrBinaryTree
        ArraBinaryTree arraBinaryTree = new ArraBinaryTree(arr);
        arraBinaryTree.preOrder();
    }
}
class ArraBinaryTree{
    private int[] arr;

    public ArraBinaryTree(int[] arr) {
        this.arr = arr;
    }

    //重载preOrder
    public void preOrder(){
        this.preOrder(0);
    }

    public void preOrder(int index){
        //如果数组为空，或者arr.length = 0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        //输出当前这个元素
        System.out.println(arr[index]);
        //向左递归遍历
        if ((index*2 + 1)< arr.length){
            preOrder(2*index+1);
        }
        //向右递归
        if ((index*2 + 2) <arr.length){
            preOrder(2*index +2);
        }
    }
}

```

#### 线索化二叉树

基本介绍：

1. n个节点的二叉链表中含有n+1个空指针域。利用二叉链表中的空指针域，存放指向该节点在==某种遍历次序==下的前驱和后驱节点的指针（这种附加的指针称为“线索”）
2. 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为**前序线索二叉树**、**中序线索二叉树**和**后续线索二叉树**三种
3. 一个节点的前一个节点，称为==前驱节点==
4. 一个结点的后一个节点，称为==后继节点==

 :computer:示例代码（线索化二叉树以及遍历线索化二叉树）

```java
package sanelee.DataStructure.binaryTree.threadedbinarytree;

/**
 * @author sanelee
 * @date 2020/5/10
 **/
public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        //测试中序线索二叉树的功能是否正确
        HeroNode root = new HeroNode(1, "tom");
        HeroNode node2 = new HeroNode(3, "jack");
        HeroNode node3 = new HeroNode(6, "smith");
        HeroNode node4 = new HeroNode(8, "mary");
        HeroNode node5 = new HeroNode(10, "king");
        HeroNode node6 = new HeroNode(14, "dim");

        //现在简单处理使用手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        threadedBinaryTree.threadedNodes();
//        threadedBinaryTree.prethreadedNodes();

        //测试：以10号节点测试
        HeroNode leftnode = node5.getLeft();
        HeroNode rightnode = node5.getRight();
        System.out.println("10号节点的前驱节点是···");
        System.out.println(leftnode);
        System.out.println("10号节点的后继节点是···");
        System.out.println(rightnode);


        System.out.println("使用线索化的方式遍历线索化二叉树");
        threadedBinaryTree.threadedList();
    }
}

//定义ThreadedBinaryTree 实现了线索化功能的二叉树
class ThreadedBinaryTree {
    private HeroNode root;
    //为了实现线索化，需要创建指向当前节点的前驱节点的指针
    private HeroNode pre = null;

    //重载threadedNodes方法
    public void threadedNodes(){
        this.threadedNodes(root);
    }
//    public void prethreadedNodes(){
//        this.prethreadedNodes(root);
//    }


    //遍历线索化二叉树的方法
    public void threadedList(){
        //定义一个变量，存储当前遍历的结点，从root开始
        HeroNode node = root;
        while ( node != null ){
            //循环找到leftType == 1 的结点，第一个找到的就是8结点
            //后面随着遍历而变化，因为当left==1时，说明该节点是按照线索化处理后的有效节点
            while (node.getLeftType() == 0){
                node = node.getLeft();
            }
            //打印当前这个节点
            System.out.println(node);
            //如果当前节点的右指针指向的时后继节点，就一直输出
            while (node.getRightType() == 1){
                //获取到当前节点的后继节点
                node = node.getRight();
                System.out.println(node);
            }
            //替换这个遍历的节点
            node = node.getRight();

        }
    }
    /**
     * 编写对二叉树进行中序线索化的方法
     * @param node 就是当前需要线索化的节点
     */
    public void threadedNodes(HeroNode node){
        //如果node == null ,不能线索化
        if (node == null){
            return;
        }
        //先线索化左子树
        threadedNodes(node.getLeft());
        //线索化当前节点
        //处理当前节点的前驱节点
        if (node.getLeft() == null){
            //让当前节点的左指针指向前驱节点
            node.setLeft(pre);
            //修改当前节点的左指针的类型,指向前驱节点
            node.setLeftType(1);
        }
        //处理后继节点
        if (pre != null && pre.getRight() == null){
            //让前驱节点的右指针指向当前节点
            pre.setRight(node);
            //修改前驱节点的右指针类型
            pre.setRightType(1);
        }
        //没处理一个节点后，让当前节点是下一个结点的前驱节点
        pre = node;

        //再线索化右子树
        threadedNodes(node.getRight());
    }
//    /**
//     * 编写对二叉树进行前序线索化的方法
//     * @param node 就是当前需要线索化的节点
//     */
//    public void prethreadedNodes(HeroNode node){
//        //如果node == null ,不能线索化
//        if (node == null){
//            return;
//        }
//
//        //先线索化当前节点
//        //处理当前节点的前驱节点
//        if (node.getLeft() == null){
//            //让当前节点的左指针指向前驱节点
//            node.setLeft(pre);
//            //修改当前节点的左指针的类型,指向前驱节点
//            node.setLeftType(1);
//        }
//        //处理后继节点
//        if (pre != null && pre.getRight() == null){
//            //让前驱节点的右指针指向当前节点
//            pre.setRight(node);
//            //修改前驱节点的右指针类型
//            pre.setRightType(1);
//        }
//        //没处理一个节点后，让当前节点是下一个结点的前驱节点
//        pre = node;
//        //线索化左子树
//        prethreadedNodes(node.getLeft());
//        //再线索化右子树
//        prethreadedNodes(node.getRight());
//    }

    public HeroNode getRoot() {
        return root;
    }

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public HeroNode proOrderSearch(int no){
        if (this.root != null){
            return root.proOrderSearch(no);
        }else {
            return null;
        }
    }

    public HeroNode infixOrderSearch(int no){
        if (this.root != null){
            return root.infixOrderSearch(no);
        }else {
            return null;
        }
    }
    public  HeroNode postOrderSearch(int no){
        if (this.root != null){
            return root.postOrderSearch(no);
        }else {
            return null;
        }
    }
    //删除节点
    public void delNode(int no){
        if (root != null){
            if (root.getNo() == no){
                root = null;
            }else {
                root.delNode(no);
            }
        }else {
            System.out.println("空树，不能删除~");
        }
    }
}
//创建HeroNode
class HeroNode {
    private int no;
    private String name;
    private HeroNode left;//默认null
    private HeroNode right;//默认null
    //说明
    //1.如果leftType == 0表示指向的是左子树，如果是1则表示指向前驱结点
    //2.如果rightType == 0表示指向的是右子树，如果是1则表示指向后继结点
    private int leftType;
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    //编写前序遍历的方法
    public void preOrder(){
        System.out.println(this);//先输出父节点
        //递归向左子树前序遍历
        if (this.left != null){
            this.left.preOrder();
        }
        //递归向右子树前序遍历
        if (this.right != null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void infixOrder(){
        //递归向左子树中序遍历
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);//先输出父节点
        //递归向右子树中序遍历
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树后序遍历
        if (this.left != null){
            this.left.postOrder();
        }
        //递归向右子树后序遍历
        if (this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);//输出父节点
    }


    /**
     * //前序遍历查找
     * @param no 查找no
     * @return 如果找到就返回该Node，如果没有找到返回null
     */
    public HeroNode proOrderSearch(int no){
        System.out.println("进入前序遍历");
        //比较当前节点是不是
        if (this.no == no){
            return this;
        }
        HeroNode resNode = null;
        //递归向左子树前序查找
        if (this.left != null){
            resNode = this.left.proOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }
        //递归向右子树前序查找
        if (this.right != null){
            resNode = this.right.proOrderSearch(no);
        }
        return resNode;
    }

    /***
     * 中序遍历查找
     * @param no 查找no
     * @return 如果找到就返回该Node，如果没有找到返回null
     */
    public HeroNode infixOrderSearch(int no){

        HeroNode resNode = null;
        //递归向左子树前序查找
        if (this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }
        System.out.println("进入中序查找");
        //比较当前节点是不是
        if (this.no == no){
            return this;
        }
        //递归向右子树前序查找
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }
    /***
     * 后序遍历查找
     * @param no 查找no
     * @return 如果找到就返回该Node，如果没有找到返回null
     */
    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        //递归向左子树前序查找
        if (this.left != null){
            resNode = this.left.postOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }

        //递归向右子树前序查找
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }if (resNode != null){
            return resNode;
        }
        //比较当前节点是不是
        System.out.println("进入后序查找");
        if (this.no == no){
            return this;
        }
        return resNode;
    }

    /**
     * 递归删除节点
     * 1. 如果删除的节点是叶子节点，则删除该节点
     * 2. 如果删除的节点是非叶子节点，则删除该子树
     * @param no
     */
    public void delNode(int no){
        if (this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if (this.left != null){
            this.left.delNode(no);
        }
        if (this.right != null){
            this.right.delNode(no);
        }

    }
}

```



#### 树结构的实际应用

##### - 堆排序

堆排序基本介绍：

1. 堆排序是利用堆这种数据结构而设计的一种排序方法，堆排序是一种选择排序，它的最坏、最好、平均复杂度均为O(nlogn)，它时不稳定排序
2. 对是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子结点的值，称为大顶堆，**注意**：没有要求节点的左孩子的值和右孩子的值的大小关系。
3. 每个节点的值都小于或等于其左右孩子结点的值，称为小顶堆。
4. 一般升序采用大顶堆，降序采用小顶堆。



###### 堆排序基本思想

1. 将待排序序列构造成一个大顶堆
2. 此时，整个序列的最大值就是堆顶的根节点
3. 将其与末尾元素进行交换，此时末尾就为最大值
4. 然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

:computer:示例代码

```java
package sanelee.DataStructure.binaryTree;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/5/11
 **/
public class HeapSort {
    public static void main(String[] args) {
        //要求将数组进行升序排列
        int arr[] = {4, 6, 8, 5, 9};
        heapSort(arr);
    }

    //编写一个堆排序的方法
    public static void heapSort(int arr[]) {
        int temp = 0 ;
        System.out.println("堆排序");
        //分步完成
//        adjustHeap(arr,1,arr.length);
//        System.out.println("第一次"+ Arrays.toString(arr));
//        adjustHeap(arr,0,arr.length);
//        System.out.println("第二次"+ Arrays.toString(arr));
        //完成最终代码
        //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
        for (int i = arr.length/2-1;i>=0;i--){
            adjustHeap(arr,i,arr.length);
        }
        for (int j = arr.length-1;j>0;j--){
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr,0,j);
        }
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 将一个数组（二叉树），调整成一个大顶堆
     * 功能：完成将以i对应的非叶子节点的树调整成大顶堆
     *
     * @param arr    待调整的数组
     * @param i      表示非叶子节点在数组中的索引
     * @param length 表示对多少个元素进行调整，length是在逐渐减少
     */

    public static void adjustHeap(int arr[], int i, int length) {
        int temp = arr[i];//先取出当前元素的值保存在一个临时变量
        //开始调整
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if (k+1 < length && arr[k] <arr[k+1]){//说明左子节点小于右子节点的值
                k++;//k 指向右子节点
            }
            if (arr[k] >temp){//如果子节点大于父节点
                arr[i] = arr[k];//把较大的值赋给当前节点
                i = k;//i指向k,继续循环比较
            }else {
                break;
            }
        }
        //当for循环结束后，我们已经将以i为父节点的树的最大值，放在了最顶上
        arr[i] = temp;//将temp放到调整后的位置
    }
}

```

##### -赫夫曼树

**基本介绍**

1. ​	给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小，成这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近

**概念举例说明**

1. ​	路径和路径长度：在一棵树中，从一个节点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层结点的路径长度为L-1
2. 结点的权及带权路径长度:若将树中结点赋给一个有着某种意义的数值，则这个数值成为该节点的权。结点的带权路径长度为：从根节点到该节点之间的路径长度与该结点的权的乘积。
3. 树的带权路径长度：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL，权值越大的节点离根节点越近的二叉树才是最优二叉树
4. WPL最小的就是赫夫曼树

**赫夫曼树创建思路分析**

​	构成赫夫曼树的步骤：

1. 将每一个数据从小到大进行排序，每个数据都是一个结点，每个节点可以看成是一颗最简单的二叉树
2. 取出根节点权值最小的两棵二叉树,组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
3. 再将这颗新的二叉树以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中所有的数据都被处理，就得到一颗赫夫曼树

:computer:示例代码：

```java
package sanelee.DataStructure.binaryTree.huffmanTree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author sanelee
 * @date 2020/5/13
 **/
public class HuffmanTree {
    public static void main(String[] args) {
        int arr[] = {13, 7, 8, 3, 29, 6, 1};
        Node node = createHuffmanTree(arr);
        //测试
        preOrder(node);
    }

    //前序遍历的方法
    public static void preOrder(Node root) {
        if (root != null) {
            root.preOrder();
        } else {
            System.out.println("空树，无法遍历");
        }
    }

    /**
     * @param arr 需要创建成赫夫曼树的数组
     * @return
     */
    //创建赫夫曼树的方法
    public static Node createHuffmanTree(int[] arr) {
        //第一步为了操作方便
        //1.遍历arr数组
        //2.将arr的每个元素构建成一个Node
        //3.将Node放入到ArrayList中
        List<Node> nodes = new ArrayList<Node>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }

        //处理的过程是一个循环的过程
        while (nodes.size() > 1) {
            //排序  从小到大
            Collections.sort(nodes);

            //取出根节点权值最小的两颗二叉树
            //（1）取出权值最小的结点（二叉树）
            Node leftNode = nodes.get(0);
            //(2)取出第二小的结点
            Node rightNode = nodes.get(1);
            //(3)构建一颗新的二叉树
            Node parent = new Node(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            //（4）从ArrayList中删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //(5)将parent加入到nodes
            nodes.add(parent);
        }
        //返回赫夫曼树的root结点
        return nodes.get(0);
    }
}


//创建节点类
//让Node实现Comparable接口实现排序
class Node implements Comparable<Node> {
    int value;//结点权值
    Node left;//指向左子节点
    Node right;//指向右子节点

    //写前序遍历方法
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        //表示从小到大排序
        return this.value - o.value;
    }
}

```

###### -赫夫曼编码

基本介绍：

1. ​	赫夫曼编码是一种编码方式，属于一种程序算法。
2. 赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一
3. 赫夫曼编码广泛地应用于数据文件压缩。其压缩率通常在20%~90%之间
4. 赫夫曼编码是可变字长编码（VLC）的一种

### 2.二叉排序树

二叉排序树：BST（Binary Sort （Search）Tree），对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。如果有相同的值，可以将该节点放在左子节点或右子节点

>**BST的创建和遍历**
>
>```java
>package sanelee.DataStructure.binaryTree.binarysorttree;
>
>/**
> * @author sanelee
> * @date 2020/5/14
> **/
>public class BinarySortTreeDemo {
>    public static void main(String[] args){
>        int[] arr ={7,3,10,12,5,1,9};
>        BinarySortTree binarySortTree = new BinarySortTree();
>        //循环的添加结点到二叉排序树
>        for (int i =0;i<arr.length;i++){
>            binarySortTree.add(new Node(arr[i]));
>        }
>        //中序遍历二叉排序树
>        System.out.println("中序遍历二叉排序树");
>        binarySortTree.infixOrder();
>
>    }
>}
>//创建二叉排序树
>class BinarySortTree{
>    private Node root;
>    //添加节点的方法
>    public void add(Node node){
>        if (root == null){
>            root = node;
>        }else {
>            root.add(node);
>        }
>    }
>    //中序遍历
>    public void infixOrder(){
>        if (root != null){
>            root.infixOrder();
>        }else {
>            System.out.println("二叉排序树为空，不能遍历");
>        }
>    }
>}
>
>class Node{
>    int value;
>    Node left;
>    Node right;
>
>    public Node(int value) {
>        this.value = value;
>    }
>
>    @Override
>    public String toString() {
>        return "Node{" +
>                "value=" + value +
>                '}';
>    }
>
>    //添加节点的方法
>    //递归的形式添加，需要满足二叉排序树的要求
>    public void add(Node node){
>        if (node==null){
>            return;
>        }
>        //判断传入的结点的值，和当前子树的根节点的关系
>        if (node.value<this.value){
>            //如果当前结点左子节点为nul
>            if (this.left == null){
>                this.left = node;
>            } else {
>                //递归的向左子树添加
>                this.left.add(node);
>            }
>        }else {
>            if (this.right==null){
>                this.right = node;
>            }else {
>                //递归的向右子树添加
>                this.right.add(node);
>            }
>        }
>    }
>    //中序遍历
>    public void infixOrder(){
>        if (this.left != null){
>            this.left.infixOrder();
>        }
>        System.out.println(this);
>        if (this.right != null){
>            this.right.infixOrder();
>        }
>    }
>}
>
>```
>
>



>二叉排序树的删除
>
>第一种情况：
>
>1. 删除叶子节点
>
>   思路
>
>   1. 需要先去找到要删除的结点 targetNode
>   2. 找到targetNode的父节点parent
>   3. 确定targetNode是parent的左子节点还是右子节点
>   4. 根据前面的情况来对应删除
>
>2. 删除只有一颗子树的节点
>
>   思路
>
>   1. 需要先去找到要删除的结点 targetNode
>
>   2. 找到targetNode的父节点parent
>
>   3. 确定targetNode的子节点是左子节点还是右子节点
>
>   4. targetNode是parent的左子节点还是右子节点
>
>   5. 如果targetNode有左子节点
>
>      1. 如果targetNode是parent的左子节点
>
>         parent.left = target.left
>
>      2. 如果targetNode是parent的右子节点
>
>         parent.right = target.left
>
>   6. 如果targetNode有右子节点
>
>      1. 如果targetNode是parent的左子节点
>
>         parent.left = target.right
>
>      2. 如果targetNode是parent的右子节点
>
>         parent.right = target.right
>
>3. 删除有两颗子树的结点
>
>   思路
>
>   1. 需要先去找到要删除的结点 targetNode
>   2. 找到targetNode的父节点parent
>   3.  从targetNode的右子树找到最小节点
>   4. 用一个临时变量，将最小节点的值保存temp
>   5. 删除该最小节点
>   6. targetNode.value=temp
>
>:computer:示例代码
>
>```java
> /**
>     *
>     * @param node 传入的节点（当前二叉排序树的根节点）
>     * @return 返回的以node为根节点的二叉排序树的最小节点的值并删除最小节点
>     */
>    public int delRightTreeMin(Node node){
>        Node target = node;
>        //循环的查找左节点，就会找到最小值
>        while (target.left != null){
>            target = target.left;
>        }
>        delNode(target.value);
>        return target.value;
>    }
>    //删除节点
>    public void delNode(int value){
>        if (root == null){
>            return;
>        }else {
>            //1.需要先去找到要删除的结点targetNode
>            Node targetNode = search(value);
>            //如果没有找到要删除的结点
>            if (targetNode == null){
>                return;
>            }
>            //如果发现当前这颗二叉排序树只有一个节点
>            if (root.left ==null&&root.right==null){
>                root = null;
>                return;
>            }
>            //去找到targetNode的父节点
>            Node parent = searchParent(value);
>            //如果要删除的结点是叶子节点
>            if (targetNode.left==null && targetNode.right == null){
>                //判断targetNode是父节点的左子节点还是右子节点
>                if (parent.left != null && parent.left.value == value){//左子节点
>                    parent.left=null;
>                }else if (parent.right!=null && parent.right.value == value){//右子节点
>                    parent.right = null;
>                }
>            }else if (targetNode.left != null && targetNode.right != null){
>                int minVal = delRightTreeMin(targetNode.right);
>                targetNode.value = minVal;
>            }else {//删除只有一棵子树的结点
>                //如果要删除的节点有左子节点
>                if (targetNode.left!=null){
>                    if (parent.left.value == value){
>                        parent.left = targetNode.left;
>                    }else if (parent.right.value == value){
>                        parent.right = targetNode.left;
>                    }
>                }else {
>                    if (parent.left.value ==value){
>                        parent.left = targetNode.right;
>                    }else if (parent.right.value == value){
>                        parent.right = targetNode.right;
>                    }
>                }
>            }
>        }
>    }
>```
>
>

### 3.平衡二叉树（AVL树 ）

基本介绍

1. 平衡二叉树也叫平衡二叉搜索树，又被称为AVL树，可以保证查询效率较高
2. 具有以下特点：他是一棵空树或他的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。平衡二叉树的常用实现方法有 红黑树、AVL、替罪羊树、Treap、伸展树等

应用案例-单旋转（左旋转）

1. 创建一个新的节点 newNode,值等于当前根结点的值
2. 把新结点的左子树设置成当前节点的左子树
3. 把新结点的右子树设置为当前节点的右子树的左子树
4. 把当前节点的值换为右子节点的值
5. 把当前节点的右子树设置成右子树的右子树
6. 把当前节点的左子树设置为新节点

右旋转：

1. 创建一个新的节点 newNode,值等于当前根结点的值
2. 把新结点的右子树设置成当前节点的右子树
3. 把新结点的左子树设置为当前节点的左子树的右子树
4. 把当前节点的值换为左子节点的值
5. 把当前节点的左子树设置成左子树的左子树
6. 把当前节点的右子树设置为新节点



:computer:示例代码：

```java
package sanelee.DataStructure.binaryTree.AVL;

/**
 * @author sanelee
 * @date 2020/5/15
 **/
public class AVLTreeDemo {
    public static void main(String[] args) {
//        int[] arr = {4,3,6,5,7,8};
        int[] arr = {10,12,8,9,7,6};
        //创建一个AVLTree对象
        AVLTree avlTree = new AVLTree();
        //添加节点
        for (int i =0;i<arr.length;i++){
            avlTree.add(new Node(arr[i]));
        }
        //遍历
        System.out.println("中序遍历");
        avlTree.infixOrder();

        System.out.println("在平衡处理后··");
        System.out.println("树的高度"+avlTree.getRoot().height());
        System.out.println("树的左子树的高度"+avlTree.getRoot().leftHeight());
        System.out.println("树的右子树的高度"+avlTree.getRoot().rightHeight());
        System.out.println("当前的根节点="+avlTree.getRoot());
    }
}
//创建AVLTree
class AVLTree{
    private Node root;

    public Node getRoot() {
        return root;
    }

    public void setRoot(Node root) {
        this.root = root;
    }

    //查找要删除的节点
    public Node search(int value) {
        if (root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    //查找父节点
    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searParent(value);
        }
    }

    /**
     * @param node 传入的节点（当前二叉排序树的根节点）
     * @return 返回的以node为根节点的二叉排序树的最小节点的值并删除最小节点
     */
    public int delRightTreeMin(Node node) {
        Node target = node;
        //循环的查找左节点，就会找到最小值
        while (target.left != null) {
            target = target.left;
        }
        delNode(target.value);
        return target.value;
    }

    /**
     * @param node 传入的节点（当前二叉排序树的根节点）
     * @return 返回的以node为根节点的二叉排序树的最大节点的值并删除最大节点
     */
    public int delLeftTreeMax(Node node) {
        Node target = node;
        //循环的查找右节点，就会找到最大值
        while (target.right != null) {
            target = target.right;
        }
        delNode(target.value);
        return target.value;
    }

    //删除节点
    public void delNode(int value) {
        if (root == null) {
            return;
        } else {
            //1.需要先去找到要删除的结点targetNode
            Node targetNode = search(value);
            //如果没有找到要删除的结点
            if (targetNode == null) {
                return;
            }
            //如果发现当前这颗二叉排序树只有一个节点
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }
            //去找到targetNode的父节点
            Node parent = searchParent(value);
            //如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null) {
                //判断targetNode是父节点的左子节点还是右子节点
                if (parent.left != null && parent.left.value == value) {//左子节点
                    parent.left = null;
                } else if (parent.right != null && parent.right.value == value) {//右子节点
                    parent.right = null;
                }
            } else if (targetNode.left != null && targetNode.right != null) {
                int minVal = delLeftTreeMax(targetNode.right);
                targetNode.value = minVal;
            } else {//删除只有一棵子树的结点
                //如果要删除的节点有左子节点
                if (targetNode.left != null) {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else if (parent.right.value == value) {
                            parent.right = targetNode.left;
                        }
                    } else {
                        root = targetNode.left;
                    }
                } else {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else if (parent.right.value == value) {
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }
                }
            }
        }
    }

    //添加节点的方法
    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    //中序遍历
    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        } else {
            System.out.println("二叉排序树为空，不能遍历");
        }
    }
}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    //返回左子树的高度
    public int leftHeight(){
        if (left == null){
            return 0;
        }
        return left.height();
    }
    //返回右子树的高度
    public int rightHeight(){
        if (right == null ){
            return 0;
        }
        return right.height();
    }


    //返回当前节点的高度，以该节点为根节点的树的高度
    public int height() {
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height())+1;
    }

    //左旋转
    private  void leftRotate(){
        //创建新的节点，以当前根节点的值创建
        Node newNode = new Node(value);
        //把新的节点的左子树设置成当前节点的左子树
        newNode.left = left;
        //把新结点的右子树设置为当前节点的右子树的左子树
        newNode.right = right.left;
        //把当前节点的值换为右子节点的值
        value = right.value;
        //把当前节点的右子树设置成右子树的右子树
        right = right.right;
        //把当前节点的左子树设置为新节点
        left=newNode;

    }
    //右旋转
    private  void rightRotate(){
        //创建新的节点，以当前根节点的值创建
        Node newNode = new Node(value);
        //把新的节点的右子树设置成当前节点的右子树
        newNode.right = right;
        //把新结点的左子树设置为当前节点的左子树的右子树
        newNode.left = left.right;
        //把当前节点的值换为左子节点的值
        value = left.value;
        //把当前节点的左子树设置成左子树的左子树
        left = left.left;
        //把当前节点的右子树设置为新节点
        right=newNode;

    }


    /**
     * 查找要删除的节点
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该节点，否则返回null
     */
    public Node search(int value) {
        if (value == this.value) {//找到
            return this;
        } else if (value < this.value) {//如果查找的值小于当前节点，那就应该向左子树递归查找
            //如果左子结点为空，就不能再找，就返回空
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {//如果查找的值不小于当前节点，那就应该向右子树递归查找
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }
    }

    /**
     * @param value 要查找的节点的值
     * @return 返回的是要查找的值的父节点
     */
    //查找要删除结点的父节点
    public Node searParent(int value) {
        //如果当前节点就是要查找的结点的父节点，就返回
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {
            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left != null) {
                return this.left.searParent(value);//向左子树递归查找
            } else if (value >= this.value && this.right != null) {
                return this.right.searParent(value);
            } else {
                return null;//没有找到父节点
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    //添加节点的方法
    //递归的形式添加，需要满足二叉排序树的要求
    public void add(Node node) {
        if (node == null) {
            return;
        }
        //判断传入的结点的值，和当前子树的根节点的关系
        if (node.value < this.value) {
            //如果当前结点左子节点为nul
            if (this.left == null) {
                this.left = node;
            } else {
                //递归的向左子树添加
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                //递归的向右子树添加
                this.right.add(node);
            }
        }
        //当添加完一个节点后，如果(右子树高度-左子树的高度）>1,左旋转
        if (rightHeight()-leftHeight()>1){
            leftRotate();
        }
        else if (leftHeight()-rightHeight()>1){
            rightRotate();
        }
    }

    //中序遍历
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }
}
```



双旋转：

1. 当符合右旋转的条件时
2. 如果它的左子树的右子树高度大于他的右子树的高度
3. 先对当前这个节点的左节点进行向左旋转
4. 在对当前节点进行向右旋转的操作即可

```java
if (rightHeight() - leftHeight() > 1) {
            //1. 如果它的右子树的左子树高度大于他的右子树的高度
            //2. 先对当前这个节点的右节点进行向右旋转
            //3. 在对当前节点进行向左旋转的操作即可
            if (right != null && right.leftHeight() > right.rightHeight()) {
                right.rightRotate();
            }
            leftRotate();

        } else if (leftHeight() - rightHeight() > 1) {
            //1. 如果它的左子树的右子树高度大于他的左子树的高度
            //2. 先对当前这个节点的左节点进行向左旋转
            //3. 在对当前节点进行向右旋转的操作即可
            if (left != null && left.rightHeight() > left.leftHeight()) {
                left.leftRotate();
            }
            rightRotate();

        }
```

### 4.红黑树

红黑树就是一种平衡的二叉查找树，本质就是为了解决二叉搜索树的平衡问题。说他平衡的意思是他不会变成瘸子，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体有下列特性：

1. 节点是红色或者黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点（NULL）
4. 每个红色节点的两个子节点都是黑色的
5. 从任意节点到其每个叶子的所有路径都包含相同的黑色节点（如果将红黑树中所有的红色节点全部去掉的话，左右子树中的黑色节点都在同一层中）



![img](https://pics6.baidu.com/feed/7aec54e736d12f2e0582b6b800289f6787356856.jpeg?token=53c56e631e52d8cd128d5aedf81c4193&s=01A67832DCB77FA376E9BDE300001022)



### 5.多路查找树

###### 二叉树与B树

二叉树的问题分析

二叉树的操作效率较高，但是也存在问题

1. 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多（比如一亿），就存在如下问题：
2. 问题1：在构建二叉树时，需要多次进行i/o操作（海量数据存在数据库或文件中），节点海量，构建二叉树时，速度有影响
3. 问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度

多叉树

1. 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）
2. 后面讲的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化

B树的基本介绍

B树通过重新组织结点，降低树的高度，并且减少i/o读写次数来提升效率，B树广泛应用于文件存储系统以及数据库系统中

###### 2-3树

2-3树基本介绍

2-3树是最简单的B树结构，具有如下特点

1. 2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）
2. 有两个子节点的节点焦耳节点，而节点要么没有子节点，要么有两个子节点
3. 有三个子结点的的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 2-3树是由而节点和三节点构成的树。

2-3树应用案例

将数列{16，24，12，32，14，26，34，10，8，28，38，20}构建成2-3树，并保证数据插入的大小顺序。

插入规则：

1. 2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）
2. 有两个子节点的节点焦耳节点，而节点要么没有子节点，要么有两个子节点
3. 有三个子结点的的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 当按照规则插入一个数到某个结点时不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件
5. 对于三节点的子树的值大小仍然遵守（BST二叉树）的规则

其他说明

除了2-3树，还有2-3-4树，概念和2-3树类似，也是一种B树

###### B树、B+树和B*树

B树的介绍

B-tree树即B树，B即Balanced，平衡的意思，有人把B-Tree翻译成B树，容易让人误解，会认为B-树是一种树，而B树又是另一种树。实际上，B-Tree就是指B树

B树的说明

1. B树的阶：结点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
2. B-树的搜索，从根节点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点
3. 关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据
4. 搜索有可能在非叶子节点结束
5. 其搜索性能等价于在关键字全集内做一次二分查找

B+树的介绍

B+树是B树的变体，也是一种多路搜索树

B+树的说明：

1. B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子节点命中），其性能也等价于在关键字全集做一次二分查找
2. 所有的关键字都出现在叶子节点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字（数据）恰好是有序的
3. 不可能在非叶子节点命中
4. 非叶子节点相当于是叶子结点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层
5. 更适合文件索引系统
6. B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。

B*树的介绍

B*树是B树的变体，也是一种多路搜索树

B*树的说明：

1. B*树定义了非叶子节点关键字个数至少为（2/3） * M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2.
2. 从第一个特点我们可以看出，B*树分配新节点的概率比B+树要低，空间使用率更高



## 10. 图

1. 线性表局限于一个直接前驱和一个直接后继的关系
2. 树也只能有一个直接前驱也就是父节点
3. 当我们需要处理多对多的关系时就需要图

>图是一种数据结构，其中结点可以具有零个或多个相邻元素，两个节点之间的连接称为边。结点也可以称为顶点

### 1.图常用概念

1. 顶点
2. 边
3. 路径
4. 无向图：顶点之间的连接没有方向
5. 有向图：顶点之间的连接有方向
6. 带权图：边上带有权值，边带权值的图也叫网

### 2.图的表示方式

图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。

#### 邻接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵的row和col表示的是1,2.....n个点。

#### 邻接表

1. 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在，会造成空间的一定损失
2. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间的浪费，邻接表由数组+链表组成

![image-20200530104411308](E:\学习\笔记\image-20200530104411308.png)

###### 代码实现图

思路分析：

1. 存储顶点String，使用ArrayList（）
2. 保存矩阵  int[][] [] []  edges

:computer:示例代码

```java
package sanelee.DataStructure.graph;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/5/30
 **/
public class Graph {

    private ArrayList<String> vertexList;//存储顶点集合
    private int[][] edges;//存储图对应的邻接矩阵
    private int numOfEdges;//表示边的数目

    public static void main(String[] args) {
        //测试
        int n = 5;//定结点的个数
        String Vertexs[] = {"A","B","C","D","E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String VertexValue:Vertexs){
            graph.insertVertex(VertexValue);
        }
        //添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        //显示
        graph.showGraph();
    }

    public Graph(int n) {
        //初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList=new ArrayList<String>(n);
        numOfEdges = 0;
    }
    //图中常用的方法
    //返回结点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }
    //显示图对应的矩阵
    public void showGraph(){
        System.out.println(" " + vertexList.toString());
        for (int i = 0;i<vertexList.size();i++){
            System.out.print(vertexList.get(i));
            System.out.println(Arrays.toString(edges[i]));
        }
    }
    //得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回结点i（下标）对应的数据0->"A",1->"B"
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    //插入结点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    /**
     *
     * @param v1 表示点的下标即是第几个顶点
     * @param v2  第二个顶点的下标
     * @param weight 顶点之间的权值
     */
    //添加边
    public void insertEdge(int v1,int v2,int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
}

```

### 3.图的遍历

图遍历介绍

>所谓图的遍历，即是对结点的访问。一个图有那么多个节点，如何遍历这些节点，需要特定策略，一般有两种访问策略
>
>1. 深度优先遍历
>2. 广度优先遍历

#### 深度优先遍历基本思想

图的深度优先搜索（Depth First Search）

1. 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的临界节点作为初始节点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一个邻接结点。
2. 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有临界节点进行横向访问
3. 显然，深度优先搜索是一个递归的过程

**深度优先遍历算法步骤**

1. 访问初始节点v,并标记结点v为已访问。
2. 查找结点v的第一个邻接结点w。
3. 若w存在，则继续执行4，如果w不存在，则回到第一步，将从v的下一个节点继续
4. 若w未被访问，对w进行深度优先遍历递归（即把w当作另一个v,然后进行步骤1，2，3）
5. 查找结点v的w邻接结点的次啊一个邻接结点，转到步骤3.

#### 广度优先遍历基本思想

图的广度优先搜索（Broad First Search）

类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些节点的邻接结点

**广度优先遍历算法步骤**

1. 访问初始节点v并标记结点v为以访问
2. 结点v入队列
3. 当队列非空时，继续执行，否则算法结束
4. 出队列，取得队头结点u
5. 查找结点u的第一个邻接结点w
6. 若节点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：
   1. 若节点w尚未被访问，则访问结点w并标记为以访问
   2. 结点w入队列
   3. 查找结点w 的继w邻接点后的下一个临界点w，转到步骤6

:computer:示例代码

```java
package sanelee.DataStructure.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

/**
 * @author sanelee
 * @date 2020/5/30
 **/
public class Graph {

    private ArrayList<String> vertexList;//存储顶点集合
    private int[][] edges;//存储图对应的邻接矩阵
    private int numOfEdges;//表示边的数目
    //定义数组boolean[]，计录某个结点是否被访问
    private boolean[] isVisited;

    public static void main(String[] args) {
        //测试
        int n = 5;//定结点的个数
        String Vertexs[] = {"A", "B", "C", "D", "E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环添加顶点
        for (String VertexValue : Vertexs) {
            graph.insertVertex(VertexValue);
        }
        //添加边
        graph.insertEdge(0, 1, 1);
        graph.insertEdge(0, 2, 1);
        graph.insertEdge(1, 2, 1);
        graph.insertEdge(1, 3, 1);
        graph.insertEdge(1, 4, 1);

        //显示
        graph.showGraph();

        //测试dfs遍历是否ok
        System.out.println("深度遍历");
        graph.dfs();
        System.out.println();
        //测试bfs遍历
        System.out.println("广度优先");
        graph.bfs();
    }

    public Graph(int n) {
        //初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;

    }

    /**
     * @param index
     * @return 如果存在就返回对应的下标，否则就返回-1
     */
    //得到第一个邻接结点的下标 w
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    //根据前一个邻接结点的下标来获取下一个邻接结点
    public int getNextNeighbor(int v1, int v2) {
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if (edges[v1][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    //深度优先遍历算法
    private void dfs(boolean[] isVisited, int i) {
        //首先我们访问该节点，输出
        System.out.print(getValueByIndex(i) + "->");
        //将节点设置为已经访问0
        isVisited[i] = true;
        //查找结点i的第一个邻接结点w
        int w = getFirstNeighbor(i);
        while (w != -1) {//说明存在
            if (!isVisited[w]) {//没有访问
                dfs(isVisited, w);
            }
            //如果w结点已经被访问过
            w = getNextNeighbor(i, w);
        }
    }

    //对dfs进行一个重载，遍历我们所有的节点，并进行dfs
    public void dfs() {
        isVisited = new boolean[5];
        //遍历所有的节点，进行dfs【回溯】
        for (int i = 0; i < getNumOfVertex(); i++) {
            if (!isVisited[i]) {
                dfs(isVisited, i);
            }
        }
    }

    //对一个结点进行广度优先遍历
    private void bfs(boolean[] isVisited, int i) {
        int u;//表示队列的头节点对应的下标
        int w;//表示邻接结点w
        //队列，计录结点访问的顺序
        LinkedList queue = new LinkedList();
        //访问结点，输出节点的信息
        System.out.print(getValueByIndex(i) + "->");
        //标记为以访问
        isVisited[i] = true;
        //将节点加入队列
        queue.addLast(i);
        while (!queue.isEmpty()) {
            //取出队列的头节点的下标
            u = (Integer) queue.removeFirst();
            //得到
            w = getFirstNeighbor(u);
            while (w != -1) {//找到
                //是否访问过
                if (!isVisited[w]) {
                    System.out.print(getValueByIndex(w) + "->");
                    //标记已经访问
                    isVisited[w] = true;
                    //入队列
                    queue.addLast(w);
                }
                //以u为前驱点，找w后面的下一个邻接点
                w = getNextNeighbor(u,w);//体现出广度优先
            }
        }
    }

    public void bfs(){
        isVisited = new boolean[5];
        for (int i = 0;i<getNumOfVertex();i++){
            if (!isVisited[i]){
                bfs(isVisited,i);
            }
        }
    }

    //图中常用的方法
    //返回结点的个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //显示图对应的矩阵
    public void showGraph() {
        System.out.println(" " + vertexList.toString());
        for (int i = 0; i < vertexList.size(); i++) {
            System.out.print(vertexList.get(i));
            System.out.println(Arrays.toString(edges[i]));
        }
    }

    //得到边的数目
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //返回结点i（下标）对应的数据0->"A",1->"B"
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //返回v1和v2的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }

    //插入结点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    /**
     * @param v1     表示点的下标即是第几个顶点
     * @param v2     第二个顶点的下标
     * @param weight 顶点之间的权值
     */
    //添加边
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
}


```

## 11. 常用10种算法

### 1. 二分查找算法（非递归）

##### 

二分查找算法（非递归）介绍

>1. 二分查找法只适用于从有序数列中进行查找（比如数字和字母等），将数列排序后在进行查找
>2. 二分查找法的运行时间为对数时间O(log~2~n)，即查找到需要的目标位置最多只需要log~2~n步，假设从[0,99]的队列（100个数，即n=100）种寻找到目标数30，则只需要查找步数为log~2~100，即最多需要查找7次

:computer:示例代码

```java
package sanelee.Algorithm.binarysearchnorecursion;

/**
 * @author sanelee
 * @date 2020/6/1
 **/
public class BinarySearchNoRecur {
    public static void main(String[] args) {
        int[] arr = {1,3,8,10,11,67,100};
        int index = binarySearch(arr, 1001);
        System.out.println("index="+ index);
    }

    /**
     *
     * @param arr 待查找的数组,arr是升序排列
     * @param target 需要查找的目标数
     * @return 返回对应的下标，-1表示没有找到
     */
    //二分查找的非递归实现
    public static int binarySearch(int[] arr,int target){
        int left = 0;
        int right = arr.length -1;
        while (left<=right){
            int mid = (left + right)/2;
            if (arr[mid] == target){
                return mid;
            }else if (arr[mid] >target){
                right = mid-1;
            }else {
                left = mid +1;
            }
        }
        return -1;
    }
}

```

### 2. 分治算法

###### 分治算法介绍

>1. 分治法是一种很重要的算法。字面意思上的解释是‘分而治之’，就是把一个复杂问题分成多个相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序，归并排序），傅里叶变换
>2. 分治算法可以求解的一些经典问题
>   - 二分搜索
>   - 大整数乘法
>   - 棋盘覆盖
>   - 合并排序
>   - 快速排序
>   - 线性时间选择
>   - 最接近点对问题
>   - 循环赛日程表
>   - 汉诺塔

###### 分治算法的基本步骤

分治法在每一层递归上都有三个步骤：

1. 分解：将原问题分解问若干个规模较小，相互独立，与原问题形式相同的子问题
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归的解各个子问题
3. 合并：将各个子问题的解合并为原问题的解

分治算法最佳实践-汉诺塔

思路分析：

1. 如果只有一个盘，A->C

2. 如果有n>=2情况，我们总是可以看作是两个盘，1.最下面的一个盘  2.最上面的所有盘

   1. 先把最上面的盘A->B
   2. 把最下面的盘A->C
   3. 把B塔的所有盘从B->C

   :computer:代码示例

   ```java
   package sanelee.Algorithm.DAC;
   
   /**
    * @author sanelee
    * @date 2020/6/1
    **/
   public class Hanoitower {
       public static void main(String[] args) {
           hanoitower(5,'A','B','C');
       }
       //汉诺塔的移动的方法
       //使用分治算法
   
       public static void hanoitower(int num, char a, char b, char c) {
           //如果只有一个盘
           if (num == 1) {
               System.out.println("第1个盘从" + a + "->" + c);
           } else {
               hanoitower(num - 1, a, c, b);
               System.out.println("第" + num + "个盘从" + a + "->" + c);
               hanoitower(num-1,b,a,c);
           }
       }
   }
   
   ```


### 3.动态规划算法

###### 动态规划算法介绍

>1. 动态规划（Dynamic Programming）算法的和心思宪法是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
>2. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解
>3. 与分治算法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是相互独立的。（即下一个字阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）
>4. 动态规划可以通过填表的方式来逐步推进，得到最优解
>
>

算法实践----背包问题

思路和图解

![image-20200602094624461](E:\学习\笔记\image-20200602094624461.png)

- 背包问题主要是指一个给定容量的背包、若干个具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包（完全背包指的是：每种物品都有无限件可用）

- 这里的问题属于01背包，即每个物品最多放一个，而无限背包可以转化为01背包。

- 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入到背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j] 。则我们有下面的结构：

  1. v[i] [0]=v[0] [j]; //表示填入表第一行和第一列是0

  2. 当w[i]>j时，：v[i] [j]=v[i-1] [j]; //当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略

  3. 当j>=w[i]时：v[i] [j]=max{v[i-1] [j], v[i]+v[i-1] [j-w[i]]} ; // 当准备加入的新增的商品的容量小于等于当前背包的容量，

     ​			//装入的方式:

     v[i-1] [j]:就是上一个单元格的装入的最大值

     v[i]：表示当前商品的价值

     v[i-1] [j-w[i]]:装入i-1商品到剩余空间j-w[i]的最大值

     当j>=w[i]时:v[i] [j]=max{v[i-1] [j], v[i]+v[i-1] [j-w[i]]} 

:computer:示例代码

```java
package sanelee.Algorithm.dynamic;

/**
 * @author sanelee
 * @date 2020/6/2
 **/
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1,4,3};//物品的重量
        int[] val = {1500,3000,2000};//物品的价值
        int m =5;//背包的重量
        int n = w.length;//物品的个数w



        //创建二维数组
        //v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int [n+1][m+1];
        //为了记录放入商品的情况，我们定一个二维数组
        int[][] path = new  int[n+1][m+1];
        //初始化第一行和第一列
        for (int i =0;i<v.length;i++){
            v[i][0] =0;//将第一列设置为0
        }
        for (int i=0;i<v[0].length;i++){
            v[0][i]=0;//将第一行设置为0
        }

        //根据前面得到的公式来动态规划处理
        for (int i =1;i<v.length;i++){//不处理第一行
            for (int j = 1;j<v[0].length;j++){//不处理第一列，j是从1开始的
                if (w[i-1]>j){
                    v[i][j]= v[i-1][j];
                }else {
                    //v[i][j] = Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);
                    if (v[i-1][j]<val[i-1]+v[i-1][j-w[i-1]]){
                        v[i][j] = val[i-1]+v[i-1][j-w[i-1]];
                        //把当前的情况记录到path
                        path[i][j] =1;
                    }else {
                        v[i][j] = v[i-1][j];
                    }
                }
            }
        }
        //输出一下v，看看目前的情况
        for (int i = 0;i<v.length;i++){
            for (int j = 0;j<v[i].length;j++){
                System.out.print(v[i][j]+" ");
            }
            System.out.println();
        }
        //输出最后我们放入的是哪些商品
       int i = path.length -1;//行的最大下标
        int j = path[0].length-1;//列的最大下标
        while (i>0 && j>0){//从path的最后开始找
            if (path[i][j] == 1){
                System.out.printf("第%d个商品放入到背包\n",i);
                j -= w[i-1];
            }
            i--;
        }
    }
}

```

### 4.KMP算法

应用场景-字符串匹配问题

1. 有一个字符串str1=“硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好”，和一个子串str2=“尚硅谷你尚硅你”
2. 现在要判断str1是否含有str2，如果存在，就返回第一次出现的位置，如果没有则返回-1

暴力匹配算法思路

假设现在str1匹配到i位置，子串str2匹配到j位置，则有：

1. 如果当前字符匹配成功（即str1[i]==str2[j]），则i++,j++,继续匹配下一个字符
2. 如果失配（即str1[i]!=str2[j]），令i=i-(j-1),j=0.相当于每次匹配失败时，i回溯，j被置为0.
3. 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间（不可行！）
4. 暴力匹配算法实现

###### KMP算法介绍

1. KMP是一个解决模式串在文本中是否出现过，如果出现过，最早出现的位置的经典算法
2. Knuth-Morris-Pratt字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串P的出现位置 ，这个算法由Donald Knuth、Vaughan Pratt\James H.Morris三人于1977年联合发表，故取这3人的姓氏命名此算法
3. KMP算法就利用之前拍断过的信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时通过next数组找到前面匹配过的位置，省去了大量的计算时间

:computer:代码示例

```java
package sanelee.Algorithm.kmp;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/6/3
 **/
public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";

        int[] next = kmpNext("ABCDABD");
        System.out.println(Arrays.toString(next));

        int index = kmpSearch(str1,str2,next);
        System.out.println("index=" + index);
    }

    /**
     *
     * @param str1 原字符串
     * @param str2 子串
     * @param next 子串对应的部分匹配表
     * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置
     */
    //KMP搜索算法
    public static int kmpSearch(String str1,String str2,int[] next){
        //遍历
        for(int i = 0,j=0;i<str1.length();i++){
            //需要考虑不相等的情况
            while (j>0 && str1.charAt(i) != str2.charAt(j)){
                j=next[j-1];
            }
            if (str1.charAt(i) == str2.charAt(j)){
                j++;
            }
            if ( j == str2.length()){//找到
                return i-j+1;
            }
        }
        return -1;
    }
    //获取到一个字符串（子串）的部分匹配值
    public static int[] kmpNext(String dest) {
        //创建一个数组，保存部分匹配值
        int[] next = new int[dest.length()];
        next[0] = 0;//如果字符串是长度为1，部分匹配值就是0
        for (int i = 1, j = 0; i < dest.length(); i++) {
            //当dest.charAt(i)！=dest.charAt(j)，我们需要从next[j-1]获取新的j
            //直到我们发现 有 dest.charAt(i) == dest.charAt(j) 成立才退出
            while (j > 0 && dest.charAt(i) != dest.charAt(j)){
                j=next[j-1];
            }
                //当dest.charAt(i)==dest.charAt(j)  满足时，部分匹配值就是+1
                if (dest.charAt(i) == dest.charAt(j)) {
                    j++;
                }
            next[i] = j;
        }
        return next;
    }

}

```

### 5.贪心算法

###### 贪心算法介绍

1. 贪婪算法（贪心算法）是指在对问题进行求解时，在每一步选择中都采取最好或着最优（即最有利）的选择，从而希望能够导致结果是最好或者最优的算法
2. 贪婪算法所得到的结果不一定是最优的结果（有时候会是最优解），但是都是相对接近最优解的结果

###### 贪心算法最佳应用

![image-20200604095652210](E:\学习\笔记\image-20200604095652210.png)

###### 思路分析

1. 遍历多有的广播电台，找到一个覆盖了最多未覆盖地区的电台（此电台可能包括一些已覆盖的地区，但没关系）
2. 将这个电台加入到一个集合中，想办法把该电台覆盖的地区在下次比较时去点
3. 重复第一步直到覆盖了全部地区

 :computer:示例代码

```java
package sanelee.Algorithm.kmp.greedy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

/**
 * @author sanelee
 * @date 2020/6/4
 **/
public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台，放入到Map
        HashMap<String, HashSet<String>> broadcasts = new HashMap<>();
        //将各个电台放入到broadcasts
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");

        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //加入到map
        broadcasts.put("K1",hashSet1);
        broadcasts.put("K2",hashSet2);
        broadcasts.put("K3",hashSet3);
        broadcasts.put("K4",hashSet4);
        broadcasts.put("K5",hashSet5);

        //存放所有的地区
        HashSet<String> allAreas = new HashSet<>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("杭州");
        allAreas.add("成都");
        allAreas.add("大连");

        //创建一个ArrayList存放选择的电台的集合
        ArrayList<String> selects = new ArrayList<>();

        //定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖地区和当前没有覆盖的地区的交集
        HashSet<String> tempSet = new HashSet<String>();
        //定义一个maxKey，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key
        //如果maxKey 不为null,则会加入到selects
        String maxKey = null;

        while (allAreas.size() != 0){//如果allAreas不为0，则表示还没有覆盖到所有地区
            //每进行一次while，需要将maxKey置空
            maxKey = null;
            //遍历broadcasts,取出对应的key
            for (String key:broadcasts.keySet()){
                //每进行一次循环，将temp清空;
                tempSet.clear();
                //当前key能够覆盖的地区
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                //求出 tempSet 和 allAreas集合的交集,交集会赋给 tempSet
                tempSet.retainAll(allAreas);

                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多
                //就需要重置maxKey
                //tempSet.size() > broadcasts.get(maxKey).size() 体现出贪心算法的特点，每次都选择最优的
                if (tempSet.size() > 0 && (maxKey==null || tempSet.size() > broadcasts.get(maxKey).size())){
                    maxKey = key;
                }
            }
            //maxKey != null,就应该将maxKey 加入到selects
            if (maxKey != null){
                selects.add(maxKey);
                //将maxKey指向的电台覆盖的地区从allAreas去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }

        }
        System.out.println("得到的选择结果是"+selects);


    }
}

```

### 6. 普里姆算法

###### 最小生成树

修路问题的本质就是最小生成树问题 ，最小生成树（Minimum Cost Spanning Tree），简称MST

1. 给定一个带权的无向连通图，如何选取一颗生成树，使树上所有边上权的总和为最小，这叫最小生成树
2. N个顶点，一定有N-1条边
3. 包含全部顶点
4. N-1条边都在图中
5. 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法

###### 普里姆算法介绍

1. 普里姆算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有（n-1）条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图
2. 普里姆算法如下：
   1. 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合
   2. 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入到集合U中，标记顶点v的visited[u]=1;
   3. 若集合U中顶点u~i~ 与集合V-U中的顶点v~j~ 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点v~j~ 加入到集合U中，将边（u~i~,v~j~）加入到集合D中，标记visited[v~j~]=1
   4. 重复步骤2，直到U与V相等，即所有的顶点都被标记为访问过，此时D中有n-1条边

###### 普里姆算法图解分析

![image-20200606093321370](E:\学习\笔记\image-20200606093321370.png)

1. 从< A >顶点开始处理 ====> < A,G >

   A-C[7]  **A-G[2]**  A-B[5] =>G

2. < A,G > 开始，将A和G顶点和他们相邻的还没有访问过的顶点进行处理====>< A,G,B >

   A-C[7]  A-B[5] **G-B[3]**  G-E[4]  G-F[6]

3. < A,G,B >开始，将A，G，B顶点和他们相邻的还没有访问过的顶点进行处理< A,G,B,E >

   A-C[7  **G-E[4]**  G-F[6]  B-D[9]

4. < A,G,B,E > ==>F //第4次大循环，对应边< E,F > 权值：5

5. < A,G,B,E,F > ==>D //第5次大循环，对应边< F,D > 权值：4

6. < A,G,B,E,F,D > ==>C //第6次大循环，对应边< A,C > 权值：7    =  ==> < A,G,B,E,F,D,C > 

:computer:示例代码：

```java
package sanelee.Algorithm.prim;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/6/6
 **/
public class PrimAlgorithm {
    public static void main(String[] args) {
        //测试图是否创建成功
        char[] data = new char[] {'A','B','C','D','E','F','G'};
        int verxs = data.length;
        //邻接矩阵的关系使用二维数组描述,10000这个大鼠表示两个点不连通
        int[][] weight = new int[][]{
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,10000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000} ,};
        //创建MGraph对象
        MGraph graph = new MGraph(verxs);
        //创建一个MinTree对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph,verxs,data,weight);
        //输出
        minTree.showGraph(graph);
        //测试普里姆算法
        minTree.prim(graph,1);
    }
}
//创建最小生成树->村庄的图
class MinTree{
    //创建图的邻接矩阵

    /**
     *
     * @param graph 图对象
     * @param verxs 图对应的顶点个数
     * @param data 图的各个顶点的值
     * @param weight 图的邻接矩阵
     */
    public void createGraph(MGraph graph,int verxs,char data[],int[][] weight){
        int i,j;
        for (i = 0;i<verxs;i++){
            graph.data[i] = data[i];
            for (j=0;j<verxs;j++){
                graph.weight[i][j] = weight[i][j];
            }
        }
    }
    //显示图的邻接矩阵
    public void showGraph(MGraph graph){
        for (int[] link:graph.weight){
            System.out.println(Arrays.toString(link));
        }
    }

    /**
     * 编写prim算法，得到最小生成树
     * @param graph 图
     * @param v 表示从图的第几个顶点开始生成‘A' -> 0 'B'->1 ....
     */
    public void prim(MGraph graph,int v){
        //visited[]表示节点（顶点）是否被访问过
        int visited[] = new int[graph.verxs];
        //visited[] 默认元素的值都是0，表示没有访问过,java默认为0
//        for (int i = 0;i<graph.verxs;i++){
//            visited[i]=0;
//        }
        //把当前这个节点标记为已访问
        visited[v] = 1;
        //h1和h2计录两个顶点的下标
        int h1 = -1;
        int h2 = -1;
        int minWeight = 10000;

        for (int k = 1;k<graph.verxs;k++){
            //这个是确定每一次生成的子图，和哪个结点的距离最近
            for(int i = 0;i<graph.verxs;i++){//i结点表示被访问过的顶点
                for (int j = 0;j<graph.verxs;j++){//j表示还没有被访问过的结点
                    if (visited[i] == 1 && visited[j] == 0 && graph.weight[i][j]<minWeight) {
                        //替换minWeight（寻找已经访问过的结点和未访问过的节点间的权值最小的边）
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            //找到一条边是最小
            System.out.println("边<" + graph.data[h1]+","+graph.data[h2] + ">权值："+minWeight);
            //将当前这个结点标记为已经访问
            visited[h2] = 1;
            //minWeight 重新设置为最大值
            minWeight = 10000;
        }
    }

}

class MGraph{
    int verxs;//表示图的节点个数
    char[] data;//存放节点数据
    int[][] weight;//存放边，就是我们的邻接矩阵

    public MGraph(int verxs){
        this.verxs = verxs;
        data = new char[verxs];
        weight = new int[verxs][verxs];
    }
}
```

### 7. 克鲁斯卡尔算法

###### 克鲁斯卡尔算法介绍

1. 克鲁斯卡尔算法，是用来求加权连通图的最小生成树的算法
2. 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路
3. 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止

:computer:示例代码

```java
package sanelee.Algorithm.kruskal;

import java.util.Arrays;

/**
 * @author sanelee
 * @date 2020/6/8
 **/
public class KruskalCase {
    private int edgeNum;//边的个数
    private char[] vertexs;//顶点数组
    private int[][] matrix;//邻接矩阵
    //使用INF表示两个顶点不能联通
    private static final  int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        char[] vertexs = {'A','B','C','D','E','F','G'};
        int[][] matrix = {
                {0,12,INF,INF,INF,16,14},
                {12,0,12,INF,INF,7,INF},
                {INF,10,0,3,5,6,INF},
                {INF,INF,3,0,4,INF,INF},
                {INF,INF,5,4,0,2,8},
                {16,7,6,INF,2,0,9},
                {14,INF,INF,INF,8,9,0}
        };
        //创建KruskalCase对象实例
        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);

        kruskalCase.print();
        kruskalCase.kruskal();

    }

    //构造器
    public KruskalCase(char[] vertexs,int[][] matrix){
        //初始化顶点数和边的个数
        int vlen = vertexs.length;

        //初始化顶点,复制拷贝的方式
        this.vertexs = new char[vlen];
        for (int i =0;i<vertexs.length;i++){
            this.vertexs[i] = vertexs[i];
        }
        //初始化边，复制拷贝的方式
        this.matrix = new int[vlen][vlen];
        for (int i=0;i<vlen;i++){
            for (int j = 0;j<vlen;j++){
                this.matrix[i][j] = matrix[i][j];
            }
        }
        //统计边
        for (int i = 0;i<vlen;i++){
            for (int j =i+1;j<vlen;j++){
                if (this.matrix[i][j] != INF){
                    edgeNum++;
                }
            }
        }
    }
    //打印邻接矩阵
    public void print(){
        System.out.println("邻接矩阵为：\n");
        for (int i = 0;i<vertexs.length;i++){
            for (int j= 0;j<vertexs.length;j++){
                System.out.printf("%12d\t",matrix[i][j]);
            }
            System.out.println();
        }
    }

    public void kruskal(){
        int index =0;//表示最后结果数组的索引
        int[] ends = new int[edgeNum];//用于保存已有最小生成树中的每个顶点在最小生成树中的终点
        //创建结果数组，保存最后的最小生成树
        EData[] rets = new EData[edgeNum];
        //获取图中所有的边的集合
        EData[] edges = getEdges();
        System.out.println("图的边的集合="+ Arrays.toString(edges)+"共"+edges.length);
        //按照边的权值大小进行排序（从小到大）
        sortEdges(edges);
        //遍历edges数组
        for (int i=0;i<edgeNum;i++){
            //获取到第i条边的第一个顶点
            int p1 = getPosition(edges[i].start);
            //获取到第i条边的第二个顶点
            int p2 = getPosition(edges[i].end);

            //获取p1这个顶点在已有的最小生成树中的终点
            int m = getEnd(ends,p1);
            //获取p2这个顶点在已有的最小生成树中的终点
            int n = getEnd(ends,p2);
            //判断是否构成回路
            if (m != n){//没有构成回路
                ends[m] = n;//设置m在已有最小生成树中的终点
                rets[index++] = edges[i];//有一条边加入到rets数组
            }
        }
        //统计并打印“最小生成树”，输出rets
        System.out.println("最小生成树为=");
        for (int i = 0;i<index;i++){
            System.out.println(rets[i]);
        }
    }

    /**
     * 对边进行排序处理，冒泡
     * @param edges 边的集合
     */
    private void sortEdges(EData[] edges){
        for (int i = 0;i<edges.length-1;i++){
            for (int j = 0;j<edges.length-1-i;j++){
                if (edges[j].weight>edges[j+1].weight){
                    EData tmp = edges[j];
                    edges[j] = edges[j+1];
                    edges[j+1] = tmp;
                }
            }
        }
    }

    /**
     *
     * @param ch 顶点的值
     * @return 返回ch顶点对应的下标，如果找不到返回-1
     */
    private int getPosition(char ch){
        for (int i = 0;i<vertexs.length;i++){
            if (vertexs[i] == ch){
                return i;
            }
        }
        //找不到，返回-1
        return -1;
    }

    /**
     * 获取图中的边，放到EData[]数组中，后面我们需要遍历该数组
     * 是通过matrix邻接矩阵来获取
     * @return
     */
    private EData[] getEdges(){
        int index = 0;
        EData[] edges = new EData[edgeNum];
        for (int i = 0 ;i<vertexs.length;i++){
            for (int j=i+1;j<vertexs.length;j++){
                if (matrix[i][j] != INF){
                    edges[index++] = new EData(vertexs[i],vertexs[j],matrix[i][j]);
                }
            }
        }
        return edges;
    }

    /**
     * 获取下表为i的顶点的终点，用于判断两个顶点的终点是否相同
     * @param ends 数组就是记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中，逐步形成的
     * @param i 表示传入的顶点对应的下标
     * @return 返回的是下标为i的这个顶点对应的终点的下标
     */
    private int getEnd(int[] ends,int i){
        while (ends[i] != 0){
            i = ends[i];
        }
        return i;
    }
}
//创建一个类EData，他的对象实例表示一条边
class EData{
    char start;//边的起点
    char end;//边的另外一个点
    int weight;//边的权值
    //构造器
    public EData(char start,char end,int weight){
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    //重写toString方法，便于输出这条边的信息
    @Override
    public String toString() {
        return "EData{" +
                "<" + start +
                "," + end +
                ",>=" + weight +
                '}';
    }
}

```

